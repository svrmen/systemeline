<!doctype html>
<html lang="ru">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>НКУ/ТР + шинопровод — ΔH только на 2D-видах; выноски помноговидовые</title>
<style>
  :root{--bg:#f6f6f6;--card:#fff;--border:#ddd;--shadow:0 6px 18px rgba(0,0,0,.06)}
  html,body{margin:0;background:var(--bg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  header{max-width:1160px;margin:16px auto 8px;padding:0 16px}
  .wrap{max-width:1160px;margin:0 auto 20px;padding:0 16px;display:grid;grid-template-columns:420px 1fr;gap:16px}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:center;margin:10px 0}
  .row-3{display:grid;gap:10px;align-items:center;margin:8px 0}
  .row-3.compact{ grid-template-columns:repeat(3, minmax(64px, 1fr)); }
  .row-3.compact input{
    width:100%;min-width:64px;max-width:92px;
    padding:6px 8px;font-size:12px;line-height:1;height:26px;
    border:1px solid #cfcfcf;border-radius:10px;background:#fafafa;
  }
  label{white-space:nowrap}
  input[type=number],select{width:100%;padding:8px 10px;border:1px solid #cfcfcf;border-radius:10px;background:#fafafa}
  input[readonly]{background:#f3f3f3}
  .btn{display:inline-block;padding:8px 12px;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
  .viewer{position:relative;background:#fff;border:1px solid var(--border);border-radius:12px;height:720px;overflow:hidden}
  .viewbar{position:absolute;left:8px;right:8px;top:8px;display:flex;gap:6px;z-index:11;justify-content:center}
  .viewbtn{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#fff;cursor:pointer;box-shadow:var(--shadow);font-size:13px}
  .viewbtn.active{background:#eef3ff;border-color:#bcd}
  #view{width:100%;height:100%;display:block;background:#fff}
  #gizmo{position:absolute;width:220px;height:220px;transform:translate(-50%,-50%);pointer-events:auto;z-index:6}
  #tag{position:absolute;left:0;top:0;transform:translate(-50%,-110%);background:#fff;border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:12px;box-shadow:var(--shadow);z-index:7}
  .prompt{position:absolute;transform:translate(-50%,-100%);background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);padding:10px;display:none;z-index:15}
  .warn{color:#c43;font-size:12px}
  .dim{position:absolute;pointer-events:auto;background:#fff;border:1px solid #ddd;border-radius:999px;padding:2px 8px;font-size:12px;box-shadow:var(--shadow);cursor:grab;user-select:none;z-index:9}
  .dim.dragging{cursor:grabbing;opacity:.95}
  .anno{position:absolute;pointer-events:auto;background:#fff;border:1px solid #ddd;border-radius:999px;padding:2px 8px;font-size:12px;box-shadow:var(--shadow);cursor:grab;user-select:none;z-index:10}
  .anno.moving{box-shadow:0 0 0 2px rgba(45,108,223,.25), var(--shadow)}
  .anchor-dot{position:absolute;width:12px;height:12px;border-radius:50%;background:#2d6cdf;border:2px solid #fff;box-shadow:var(--shadow);cursor:pointer;z-index:10}
  .anchor-dot.moving{box-shadow:0 0 0 2px rgba(45,108,223,.25), var(--shadow)}
  .toolbar{position:absolute;right:10px;bottom:10px;display:flex;gap:8px;z-index:8}
  .iconbtn{border:1px solid var(--border);background:#fff;border-radius:10px;padding:6px 10px;cursor:pointer;box-shadow:var(--shadow)}
  #spec{margin-top:10px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px}
  #spec h3{margin:0 0 6px;font-size:15px}
  .spec-row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:2px 0}
  .sub{color:#555}
  table{width:100%;border-collapse:collapse;margin-top:6px}
  th,td{padding:6px 8px;border-bottom:1px solid #eee;text-align:left}
  .hid{display:none}
</style>

<header><b>НКУ/Трансформатор + шинопровод</b> — ΔH скрыта в ISO; выноски запоминаются по видам</header>

<div class="wrap">
  <div class="panel">
    <div class="row"><label>Материал шин</label>
      <select id="mat"><option value="AL" selected>Алюминий (Al)</option><option value="CU">Медь (Cu)</option></select>
    </div>
    <div class="row"><label>Номинальный ток, A</label><select id="rating"></select></div>
    <div class="row"><label>Степень защиты</label><select id="ip"><option>IP55</option><option>IP65</option></select></div>

    <div class="row"><label>Начало трассы</label>
      <select id="startType">
        <option value="NKU" selected>ГРЩ</option>
        <option value="TR">Трансформатор</option>
      </select>
    </div>
    <div class="row-3 compact">
      <input id="startW" type="number" value="600" title="Начало W" placeholder="W">
      <input id="startD" type="number" value="600" title="Начало D" placeholder="D">
      <input id="startH" type="number" value="2200" title="Начало H" placeholder="H">
    </div>

    <div class="row"><label>Конец трассы</label>
      <select id="endType">
        <option value="ENDCAP" selected>Заглушка</option>
        <option value="NKU">ГРЩ</option>
      </select>
    </div>
    <div id="endDims" class="row-3 compact hid">
      <input id="endW" type="number" value="600" title="Конец W" placeholder="W">
      <input id="endD" type="number" value="600" title="Конец D" placeholder="D">
      <input id="endH" type="number" value="2200" title="Конец H" placeholder="H">
    </div>

    <div class="row"><label><b>Длина сегмента (модуль), мм</b></label><input id="moduleLen" type="number" value="3000"></div>

    <div class="row"><label>Крепления</label>
      <select id="mountOn"><option value="1" selected>есть</option><option value="0">нет</option></select>
    </div>
    <div class="row"><label>Целевой шаг крепления, мм</label><input id="mountStep" type="number" value="1000"></div>

    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="calc">Рассчитать разбиение</button>
      <button class="btn" id="uncalc">Отменить разбиение</button>
    </div>
    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="undo">Отменить участок</button>
      <button class="btn" id="clear">Сброс</button>
    </div>
    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="fit">Подогнать</button>
      <button class="btn" id="save">Сохранить PNG</button>
    </div>
    <div class="row">
      <button class="btn" id="addAnno">➕ Выноска</button>
    </div>

    <div id="msg" class="warn"></div>

    <div id="spec" style="display:none">
      <h3>Спецификация</h3>
      <div class="spec-row"><div>Материал / номинал / IP</div><div id="spHeader"></div></div>
      <div class="spec-row"><div>Модуль (стандартная длина)</div><div id="spModule"></div></div>
      <div class="spec-row"><div>Итого длина трассы</div><div id="spTotalLen"></div></div>
      <div class="spec-row"><div>Блок подключения к НКУ</div><div id="spNkuBlocks"></div></div>
      <div class="spec-row"><div>Блок подключения к ТР</div><div id="spTrBlocks"></div></div>
      <div class="spec-row"><div>Заглушка на конце</div><div id="spEndCap"></div></div>
      <div class="spec-row"><div>Соединители — всего</div><div id="spJointsTotal"></div></div>
      <div class="spec-row sub"><div>— модульная разбивка</div><div id="spJointsMod"></div></div>
      <div class="spec-row sub"><div>— на углах (по 2)</div><div id="spJointsCorners"></div></div>
      <div class="spec-row sub"><div>— у подключения к НКУ (по 1)</div><div id="spJointsNku"></div></div>
      <div class="spec-row sub"><div>— у подключения к ТР (по 1)</div><div id="spJointsTr"></div></div>
      <div class="spec-row"><div>Повороты: вертикальные</div><div id="spVert"></div></div>
      <div class="spec-row"><div>Повороты: горизонтальные</div><div id="spHoriz"></div></div>
      <div class="spec-row"><div>Крепления, шт</div><div id="spMounts"></div></div>
      <div style="margin:6px 0 2px;font-weight:600">Сегменты по длинам</div>
      <table id="spTable"><thead><tr><th>Длина, мм</th><th>Кол-во, шт</th></tr></thead><tbody></tbody></table>
      <div style="margin-top:8px"><button class="btn" id="saveCSV">Сохранить CSV</button></div>
    </div>
  </div>

  <div class="viewer" id="wrap">
    <div class="viewbar" id="viewbar">
      <button class="viewbtn active" data-view="ISO">Изометрия</button>
      <button class="viewbtn" data-view="TOP">Сверху</button>
      <button class="viewbtn" data-view="FRONT">Спереди</button>
      <button class="viewbtn" data-view="BACK">Сзади</button>
      <button class="viewbtn" data-view="LEFT">Слева</button>
      <button class="viewbtn" data-view="RIGHT">Справа</button>
    </div>

    <canvas id="view"></canvas>
    <canvas id="gizmo" width="220" height="220"></canvas>
    <div id="tag">направление: —</div>

    <!-- ввод длины нового участка -->
    <div id="lenPopup" class="prompt">
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="lenInput" type="number" min="1" step="100" placeholder="длина, мм (≥400)">
        <div><button class="btn" id="ok">OK</button><button class="btn" id="cancel">Отмена</button></div>
      </div>
      <div class="warn" id="hint" style="margin-top:6px"></div>
    </div>

    <!-- правка длины -->
    <div id="editPopup" class="prompt">
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="editInput" type="number" min="1" step="100" placeholder="новая длина, мм (≥400)">
        <div><button class="btn" id="editOk">OK</button><button class="btn" id="editCancel">Отмена</button></div>
      </div>
    </div>

    <!-- окно ввода текста выноски -->
    <div id="annoPopup" class="prompt">
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="annoInput" type="text" placeholder="текст выноски">
        <div><button class="btn" id="annoOk">OK</button><button class="btn" id="annoCancel">Отмена</button></div>
      </div>
    </div>

    <div class="toolbar"><button class="iconbtn" id="btnFS" title="Во весь экран">⛶</button><button class="iconbtn" id="saveImg">PNG</button></div>

    <!-- слои HTML-элементов -->
    <div id="dimLayer"></div>
    <div id="annoLayer"></div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', ()=>{(function(){
/* ===== справочники ===== */
const R_AL=[400,500,630,800,1000,1200,1250,1600,2000,2500,3200,4000,5000];
const R_CU=[400,500,630,800,1000,1200,1250,1600,2000,2500,3200,4000,5000,6300];
const WIDTH_AL={400:78,500:78,630:78,800:78,1000:100,1200:128,1250:128,1600:166,2000:205,2500:292,3200:368,4000:476,5000:560};
const WIDTH_CU={400:82,500:82,630:82,800:82,1000:120,1200:120,1250:120,1600:160,2000:220,2500:290,3200:360,4000:570,5000:570,6300:570};
const VERT_ELBOW={a:320,b:320};
const H_ELBOW_BY_R={400:[260,260],500:[260,260],630:[260,260],800:[260,260],1000:[270,270],1200:[290,290],1250:[290,290],1600:[310,310],2000:[220,220],2500:[370,370],3200:[410,410],4000:[460,450],5000:[500,500],6300:[500,500]};
const MIN_LEN=400;
/* неизменяемые геометрии */
const BUS_H=118;          // высота сечения шин
const JOINT_LEN=100;      // соединительный блок (длина по оси)
const MOUNT_ALONG=10;     // крепление вдоль оси
const MOUNT_THICK=10;     // крепление по Z

/* ===== DOM/канвас/камера ===== */
const $=id=>document.getElementById(id);
const wrap=$('wrap'), cvs=$('view'), ctx=cvs.getContext('2d');
const giz=$('gizmo'), gz=giz.getContext('2d'), tag=$('tag'), msg=$('msg');
const pop=$('lenPopup'), lenInput=$('lenInput'), okBtn=$('ok'), cancelBtn=$('cancel'), hint=$('hint');
const epop=$('editPopup'), editInput=$('editInput');
const apop=$('annoPopup'), ainput=$('annoInput'), aok=$('annoOk'), acancel=$('annoCancel');
const dimLayer=$('dimLayer'), annoLayer=$('annoLayer'), btnFS=$('btnFS');

let viewMode='ISO';
const DPR=Math.max(1,window.devicePixelRatio||1);
const ISO=Math.PI/6, C=Math.cos(ISO), S=Math.sin(ISO);
let proj=(x,y,z)=>[(x-y)*C,(x+y)*S - z];

function setProjection(mode){
  viewMode=mode;
  if(mode==='ISO'){ proj=(x,y,z)=>[(x-y)*C,(x+y)*S - z]; }
  else if(mode==='TOP'){   proj=(x,y,z)=>[ x, -y ]; }
  else if(mode==='FRONT'){ proj=(x,y,z)=>[ x, -z ]; }
  else if(mode==='BACK'){  proj=(x,y,z)=>[ -x, -z ]; }
  else if(mode==='LEFT'){  proj=(x,y,z)=>[ y, -z ]; }
  else if(mode==='RIGHT'){ proj=(x,y,z)=>[ -y, -z ]; }
  document.querySelectorAll('.viewbtn').forEach(b=>b.classList.toggle('active', b.dataset.view===mode));
  fit();
}
document.querySelectorAll('.viewbtn').forEach(b=>b.addEventListener('click', ()=>setProjection(b.dataset.view)));

let panX=0, panY=0, scale=1;
const apply=()=>ctx.setTransform(DPR*scale,0,0,DPR*scale,panX*DPR,panY*DPR);
function resize(){ cvs.width=Math.floor(wrap.clientWidth*DPR); cvs.height=Math.floor(wrap.clientHeight*DPR); draw(); }
addEventListener('resize', resize);
let drag=false, sx=0, sy=0;
wrap.addEventListener('pointerdown', e=>{ if(e.target.closest('#gizmo, .viewbar, .prompt, .anno, .dim, .toolbar, .anchor-dot')) return; drag=true; sx=e.clientX; sy=e.clientY; wrap.setPointerCapture(e.pointerId); });
wrap.addEventListener('pointermove', e=>{ if(!drag) return; panX+=e.clientX-sx; panY+=e.clientY-sy; sx=e.clientX; sy=e.clientY; draw(); updateEditPopupPosition(); });
wrap.addEventListener('pointerup', ()=>drag=false);
wrap.addEventListener('wheel', e=>{ e.preventDefault(); const k=Math.exp(-e.deltaY*0.001), r=wrap.getBoundingClientRect(), mx=e.clientX-r.left, my=e.clientY-r.top; const zx=(mx-panX)/scale, zy=(my-panY)/scale; scale*=k; panX=mx-zx*scale; panY=my-zy*scale; draw(); updateEditPopupPosition(); },{passive:false});

/* ===== утилиты координат ===== */
function screenToLocal(e){ const r=wrap.getBoundingClientRect(); return {x:(e.clientX-r.left-panX)/scale, y:(e.clientY-r.top-panY)/scale}; }
function localToScreen(u,v){ return {x:panX+scale*u, y:panY+scale*v}; }

/* ===== модель/параметры ===== */
const state={
  segs:[], lastDir:'+Z', calc:false, module:3000, mountsOn:true,
  editingIdx:null,
  dimOffsets:{ISO:{},TOP:{},FRONT:{},BACK:{},LEFT:{},RIGHT:{}}, // offsets для L/H и ΔH
  annos:[], addAnnoMode:false,
  movingAnno:{id:null, what:null, view:null} // what: 'box' | 'anchor'
};
const P=()=>({
  startType:$('startType').value, endType:$('endType').value,
  startW:+$('startW').value, startD:+$('startD').value, startH:+$('startH').value,
  endW:+$('endW').value, endD:+$('endD').value, endH:+$('endH').value,
  busW:( $('mat').value==='CU' ? WIDTH_CU : WIDTH_AL )[+$('rating').value] || 78,
  busH:BUS_H
});
const originTop=()=>{const p=P();return [p.startW/2,p.startD/2,p.startH];};
const axis=d=>d[1]; const sgn=d=>d[0]==='+'?1:-1;
const adv=(p,dir,dist)=>{const a=axis(dir),s=sgn(dir); return a==='X'?[p[0]+s*dist,p[1],p[2]]:a==='Y'?[p[0],p[1]+s*dist,p[2]]:[p[0],p[1],p[2]+s*dist];};
const endPoint=()=>{let [x,y,z]=originTop(); for(const s of state.segs){const L=s.len|0; if(s.dir==='+X')x+=L; else if(s.dir==='-X')x-=L; if(s.dir==='+Y')y+=L; else if(s.dir==='-Y')y-=L; if(s.dir==='+Z')z+=L; else if(s.dir==='-Z')z-=L;} return [x,y,z];};

/* ===== примитивы ===== */
function line3(a,b,col='#111',lw=1/scale){ const p=proj(...a), q=proj(...b); ctx.lineWidth=lw; ctx.strokeStyle=col; ctx.beginPath(); ctx.moveTo(p[0],p[1]); ctx.lineTo(q[0],q[1]); ctx.stroke(); }
function fillPoly3(pts, fill, alpha){ const p=pts.map(v=>proj(...v)); ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=fill; ctx.beginPath(); ctx.moveTo(p[0][0],p[0][1]); for(let i=1;i<p.length;i++) ctx.lineTo(p[i][0],p[i][1]); ctx.closePath(); ctx.fill(); ctx.restore(); }
function box(x,y,z,w,d,h){
  const v=[[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y+d,z],[x,y,z+h],[x+w,y,z+h],[x+w,y+d,z+h],[x,y+d,z+h]];
  line3(v[0],v[4]); line3(v[1],v[5]); line3(v[2],v[6]); line3(v[3],v[7]);
  line3(v[4],v[5]); line3(v[5],v[6]); line3(v[6],v[7]); line3(v[7],v[4]);
  line3(v[0],v[1]); line3(v[1],v[2]); line3(v[2],v[3]); line3(v[3],v[0]);
}
function solidBox(x,y,z,w,d,h,color='rgb(52,168,83)',alpha=0.5){
  const v=[[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y+d,z],[x,y,z+h],[x+w,y,z+h],[x+w,y+d,z+h],[x,y+d,z+h]];
  const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
  faces.forEach(f=>fillPoly3([v[f[0]],v[f[1]],v[f[2]],v[f[3]]],color,alpha));
  line3(v[0],v[4]); line3(v[1],v[5]); line3(v[2],v[6]); line3(v[3],v[7]);
  line3(v[4],v[5]); line3(v[5],v[6]); line3(v[6],v[7]); line3(v[7],v[4]);
  line3(v[0],v[1]); line3(v[1],v[2]); line3(v[2],v[3]); line3(v[3],v[0]);
}

/* ===== углы (моноблок) ===== */
const VEC={X:[1,0,0],Y:[0,1,0],Z:[0,0,1]};
function dirVec(d){const a=axis(d), s=sgn(d); const v=VEC[a]; return [v[0]*s, v[1]*s, v[2]*s];}
function cross(a,b){return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];}
function madd(o,u,su,v,sv,n,sn){return [o[0]+u[0]*su+v[0]*sv+n[0]*sn, o[1]+u[1]*su+v[1]*sv+n[1]*sn, o[2]+u[2]*su+v[2]*sv+n[2]*sn];}
function LpolyCornerSolid(lenA,lenB,half){ return [[-lenA,-half],[+half,-half],[+half,+lenB],[-half,+lenB],[-half,+half],[-lenA,+half]]; }
function extrudeSolid(poly, thick, O, U, V, N){
  const t2=thick/2; const up=poly.map(p=>madd(O,U,p[0],V,p[1],N,+t2)); const dn=poly.map(p=>madd(O,U,p[0],V,p[1],N,-t2));
  const fill='rgb(60,110,220)', a=0.6; fillPoly3(dn,fill,a); for(let i=0;i<up.length;i++){ const j=(i+1)%up.length; fillPoly3([up[i],up[j],dn[j],dn[i]],fill,a);} fillPoly3(up,fill,a);
  for(let i=0;i<up.length;i++){ line3(up[i], up[(i+1)%up.length]); line3(up[i], dn[i]); }
}
function elbowCuts(dirA, dirB){
  const a1=axis(dirA), a2=axis(dirB);
  if(a1===a2) return {a:0,b:0};
  if(a1==='Z' || a2==='Z') return {...VERT_ELBOW};
  const r=+$('rating').value, pair=H_ELBOW_BY_R[r]||[260,260];
  return {a:pair[0], b:pair[1]};
}
function elbowSolidAtVertex(vertex, fromDir, toDir, aLen, bLen, bw, bh){
  const U=dirVec(fromDir), V=dirVec(toDir), N=cross(U,V);
  const vertical = (axis(fromDir)==='Z' || axis(toDir)==='Z');
  const thick = vertical ? bw : bh;
  const half  = vertical ? (bh/2) : (bw/2);
  const poly  = LpolyCornerSolid(aLen, bLen, half);
  extrudeSolid(poly, thick, vertex, U, V, N);
}

/* ===== соединители (зелёные) ===== */
const JOINT_COLOR='rgb(52,168,83)'; const JOINT_A=.5;
function drawJointBlocksByModule(startPos, cur, Ldraw, startOffset, bw, bh){
  const m=state.module|0; if(!(m>0)) return;
  const depth=JOINT_LEN; const full=Math.floor((cur.len|0)/m);
  for(let k=1;k<=full;k++){
    const d=k*m - startOffset; if(d<=0 || d>=Ldraw) continue;
    const p=adv(startPos,cur.dir,d); const a=axis(cur.dir);
    if(a==='Z'){ solidBox(p[0]-bw/2, p[1]-bw/2, p[2]-depth/2, bw, bw, depth, JOINT_COLOR, JOINT_A); }
    if(a==='X'){ solidBox(p[0]-depth/2, p[1]-bw/2, p[2]-BUS_H/2, depth, bw, BUS_H, JOINT_COLOR, JOINT_A); }
    if(a==='Y'){ solidBox(p[0]-bw/2, p[1]-depth/2, p[2]-BUS_H/2, bw, depth, BUS_H, JOINT_COLOR, JOINT_A); }
  }
}

/* ===== крепления (оранжевые) ===== */
const SP_MIN=800, SP_MAX=1100;
function intervalFill(a,b, haveA, haveB, target){
  const L=b-a; const pts=[]; if(L<=0) return pts;
  if(haveA && haveB){
    if(L<=SP_MAX) return pts;
    let gaps=Math.ceil(L/SP_MAX), s=L/gaps;
    while(s<SP_MIN && gaps>1){ gaps--; s=L/gaps; }
    for(let i=1;i<gaps;i++) pts.push(a+i*s);
    return pts;
  }
  if(!haveA && !haveB){
    if(L<SP_MIN) return pts;
    let m=Math.max(0, Math.round(L/Math.max(SP_MIN,Math.min(SP_MAX,target))) );
    let s=L/(m+1);
    while(s>SP_MAX){ m++; s=L/(m+1); }
    while(s<SP_MIN && m>0){ m--; s=L/(m+1); }
    for(let i=1;i<=m;i++) pts.push(a+i*s);
    return pts;
  }
  let m=Math.max(0, Math.round(L/Math.max(SP_MIN,Math.min(SP_MAX,target))) - 1);
  let s=L/(m+1);
  while(s>SP_MAX){ m++; s=L/(m+1); }
  while(s<SP_MIN && m>0){ m--; s=L/(m+1); }
  for(let i=1;i<=m;i++) pts.push(a+i*s);
  return pts;
}
function mountPositionsForSegment(startPos, cur, Ldraw, startCut, endCut, prev, next, target){
  const out=[]; if(axis(cur.dir)==='Z') return out;
  const hasStartCorner = !!(prev && axis(prev.dir)!==axis(cur.dir));
  const hasEndCorner   = !!(next && axis(next.dir)!==axis(cur.dir));
  const anchors=[];
  if(hasStartCorner && Ldraw>=200) anchors.push(200);
  if(hasEndCorner   && Ldraw>=200) anchors.push(Ldraw-200);
  anchors.sort((a,b)=>a-b);
  if(anchors.length===0){
    out.push(...intervalFill(0, Ldraw, false, false, target));
  }else{
    out.push(...intervalFill(0, anchors[0], false, true, target));
    for(let i=0;i<anchors.length-1;i++){
      out.push(anchors[i], ...intervalFill(anchors[i], anchors[i+1], true, true, target));
    }
    const last=anchors[anchors.length-1];
    out.push(last, ...intervalFill(last, Ldraw, true, false, target));
  }
  const uniq=[], seen=new Set();
  for(const d of out){ const v=Math.max(0, Math.min(Ldraw, d)); const k=v.toFixed(2); if(!seen.has(k)){ seen.add(k); uniq.push(v); } }
  return uniq;
}
function drawMountsSmart(startPos, cur, Ldraw, startCut, endCut, prev, next, bw, bh){
  if($('mountOn').value!=='1') return 0;
  const target=+$('mountStep').value||1000;
  const arr=mountPositionsForSegment(startPos,cur,Ldraw,startCut,endCut,prev,next,target);
  if(arr.length===0) return 0;
  for(const d of arr){
    const C=adv(startPos,cur.dir,d);
    if(axis(cur.dir)==='X'){
      const x0=C[0]-MOUNT_ALONG/2, y0=C[1]-bw/2, z0=C[2]-BUS_H/2 - MOUNT_THICK;
      solidBox(x0, y0, z0, MOUNT_ALONG, bw, MOUNT_THICK, 'rgb(255,140,0)', .55);
    }else if(axis(cur.dir)==='Y'){
      const y0=C[1]-MOUNT_ALONG/2, x0=C[0]-bw/2, z0=C[2]-BUS_H/2 - MOUNT_THICK;
      solidBox(x0, y0, z0, bw, MOUNT_ALONG, MOUNT_THICK, 'rgb(255,140,0)', .55);
    }
  }
  return arr.length;
}

/* ===== выбор/редактирование ===== */
function distPointSeg(px,py,x1,y1,x2,y2){ const vx=x2-x1,vy=y2-y1,wx=px-x1,wy=py-y1; const t=Math.max(0,Math.min(1,(vx*wx+vy*wy)/(vx*vx+vy*vy||1))); const dx=x1+t*vx-px,dy=y1+t*vy-py; return {d:Math.hypot(dx,dy), t}; }
function pickSegByPoint(e, useCuts){
  const r=wrap.getBoundingClientRect(); const lx=(e.clientX-r.left-panX)/scale, ly=(e.clientY-r.top-panY)/scale;
  let pos=originTop(), idx=-1, best=1e9, bestT=0;
  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const sc=useCuts && prev ? elbowCuts(prev.dir, cur.dir).b : 0;
    const ec=useCuts && next ? elbowCuts(cur.dir, next.dir).a : 0;
    const start=adv(pos,cur.dir,sc); const Ldraw=Math.max(0,L-sc-ec);
    const p1=proj(...start), p2=proj(...adv(start,cur.dir,Ldraw));
    const r2=distPointSeg(lx,ly,p1[0],p1[1],p2[0],p2[1]); if(r2.d<18/scale && r2.d<best){ best=r2.d; idx=i; bestT=sc + r2.t*Ldraw; }
    pos=adv(pos,cur.dir,L);
  }
  return {idx, along:bestT};
}
function segMid(i, withCuts){
  let pos=originTop();
  for(let k=0;k<state.segs.length;k++){
    const cur=state.segs[k], L=cur.len|0, prev=state.segs[k-1], next=state.segs[k+1];
    const sc=withCuts && prev? elbowCuts(prev.dir,cur.dir).b : 0;
    const ec=withCuts && next? elbowCuts(cur.dir,next.dir).a : 0;
    const start=adv(pos,cur.dir,sc);
    const Ldraw=Math.max(0,L-sc-ec);
    if(k===i){
      const mid=adv(start,cur.dir,Ldraw/2); const p2=proj(...mid); return localToScreen(p2[0],p2[1]);
    }
    pos=adv(pos,cur.dir,L);
  }
  return {x:panX,y:panY};
}

/* ===== трасса/ΔH ===== */
function segBox(start,dir,L,bw,bh){
  const s=sgn(dir), a=axis(dir);
  if(a==='Z'){ const x=start[0]-bw/2, y=start[1]-bw/2, z=s>0?start[2]:start[2]-L; box(x,y,z,bw,bw,L); }
  if(a==='X'){ const x=s>0?start[0]:start[0]-L, y=start[1]-bw/2, z=start[2]-bh/2; box(x,y,z,L,bw,bh); }
  if(a==='Y'){ const x=start[0]-bw/2, y=s>0?start[1]:start[1]-L, z=start[2]-bh/2; box(x,y,z,bw,L,bh); }
}
function drawEndCap(bw,bh){
  if($('endType').value!=='ENDCAP') return;
  const depth=JOINT_LEN, end=endPoint();
  const last = state.segs[state.segs.length-1] || {dir:'+Z',len:0};
  const a=axis(last.dir);
  if(a==='Z'){ solidBox(end[0]-bw/2,end[1]-bw/2,end[2]-depth/2,bw,bw,depth,'rgb(220,0,0)',.55); }
  if(a==='X'){ solidBox(end[0]-depth/2,end[1]-bw/2,end[2]-BUS_H/2,depth,bw,BUS_H,'rgb(220,0,0)',.55); }
  if(a==='Y'){ solidBox(end[0]-bw/2,end[1]-depth/2,end[2]-BUS_H/2,bw,depth,BUS_H,'rgb(220,0,0)',.55); }
}

function getDimOffset(key){ return state.dimOffsets[viewMode][key] || {dx:0,dy:0}; }
function setDimOffset(key,dx,dy){ state.dimOffsets[viewMode][key]={dx,dy}; }

/* —— ΔH: скрыта в ISO, видна в остальных видах —— */
function renderDeltaH(){
  if(viewMode==='ISO') return;                  // <<<<<< ТУТ: не показываем в ISO
  const p=P();
  if($('endType').value!=='NKU') return;        // заглушка не учитывается

  const topStart = originTop()[2];
  const baseStart = topStart - p.startH;
  const endTop = endPoint()[2];
  const baseEnd = endTop - p.endH;
  const delta = Math.abs(baseEnd - baseStart) | 0;

  const sPt = proj(p.startW/2, p.startD/2, baseStart);
  const ePt = proj(endPoint()[0], endPoint()[1], baseEnd);
  const mid = {u:(sPt[0]+ePt[0])/2, v:(sPt[1]+ePt[1])/2};

  const base = localToScreen(mid.u, mid.v);
  const key='__deltaH';
  const off=getDimOffset(key);
  const x=base.x + (off.dx||0), y=base.y + (off.dy||0);

  const el=document.createElement('div'); el.className='dim'; el.textContent=`ΔH = ${delta} мм`;
  el.style.left=x+'px'; el.style.top=y+'px';

  let dragging=false, sx=0, sy=0, startDX=0, startDY=0;
  el.addEventListener('pointerdown', e=>{
    dragging=true; el.classList.add('dragging'); sx=e.clientX; sy=e.clientY;
    startDX=off.dx||0; startDY=off.dy||0; el.setPointerCapture(e.pointerId);
  });
  el.addEventListener('pointermove', e=>{
    if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy;
    el.style.left=(base.x + startDX + dx)+'px'; el.style.top=(base.y + startDY + dy)+'px';
  });
  el.addEventListener('pointerup', ()=>{
    if(!dragging) return; dragging=false; el.classList.remove('dragging');
    const dx=parseFloat(el.style.left)-base.x; const dy=parseFloat(el.style.top)-base.y;
    setDimOffset(key, dx, dy);
  });

  dimLayer.appendChild(el);
}

/* ===== рисование пути и размерных бейджей L/H ===== */
function drawPath(){
  const prm=P(), bw=prm.busW, bh=prm.busH;
  let pos=originTop(); dimLayer.innerHTML='';

  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const startCut = prev ? elbowCuts(prev.dir, cur.dir).b : 0;
    const endCut   = next ? elbowCuts(cur.dir, next.dir).a : 0;

    const startPos=adv(pos,cur.dir,startCut);
    const Ldraw=Math.max(0,L-startCut-endCut);

    if(Ldraw>0){
      segBox(startPos,cur.dir,Ldraw,bw,bh);

      if(state.calc){
        drawJointBlocksByModule(startPos,cur,Ldraw,startCut,bw,bh);
        drawMountsSmart(startPos,cur,Ldraw,startCut,endCut,prev,next,bw,bh);
      }

      const mid=adv(startPos,cur.dir,Ldraw/2); const p2=proj(...mid);
      const base = localToScreen(p2[0], p2[1]);
      const prefix = (axis(cur.dir)==='Z') ? 'H' : 'L';
      const label = `${prefix} = ${L} мм`;
      const key=i;
      const off=getDimOffset(key);
      const scrX=base.x+(off.dx||0), scrY=base.y+(off.dy||0);

      if(state.calc){
        const el=document.createElement('div'); el.className='dim'; el.textContent=label; el.dataset.idx=i;
        el.style.left=scrX+'px'; el.style.top=scrY+'px';
        let dragging=false, sx=0, sy=0, startDX=0, startDY=0;
        el.addEventListener('pointerdown', e=>{
          dragging=true; el.classList.add('dragging'); sx=e.clientX; sy=e.clientY;
          startDX=off.dx||0; startDY=off.dy||0; el.setPointerCapture(e.pointerId);
        });
        el.addEventListener('pointermove', e=>{
          if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy;
          el.style.left=(base.x + startDX + dx)+'px'; el.style.top =(base.y + startDY + dy)+'px';
        });
        el.addEventListener('pointerup', ()=>{
          if(!dragging) return; dragging=false; el.classList.remove('dragging');
          const dx=parseFloat(el.style.left)-base.x; const dy=parseFloat(el.style.top)-base.y; setDimOffset(key, dx, dy);
        });
        el.addEventListener('dblclick', (ev)=>{
          ev.stopPropagation(); state.editingIdx=i; epop.style.display='block'; updateEditPopupPosition(); editInput.value=state.segs[i].len|0; setTimeout(()=>editInput.focus(),0);
        });
        dimLayer.appendChild(el);
      }
    }

    if(next){
      const cuts = elbowCuts(cur.dir,next.dir);
      const vertex = adv(pos, cur.dir, L);
      if(cuts.a>0 || cuts.b>0) elbowSolidAtVertex(vertex, cur.dir, next.dir, cuts.a, cuts.b, bw, bh);
    }

    pos=adv(pos,cur.dir,L);
  }

  renderDeltaH();
}

/* ===== шкафы / база пола для фасадов ===== */
function drawStartCab(){
  const p=P(); const topZ = originTop()[2]; const baseZ = topZ - p.startH;
  box(0,0,baseZ,p.startW,p.startD,p.startH);
  box(p.startW/2-60,p.startD/2-60,topZ,120,120,8);
  box(p.startW/2-110,p.startD/2-110,topZ,220,220,4);
}
function drawEndCab(){
  if($('endType').value!=='NKU') return;
  const p=P(), pad1=8, pad2=4; const end=endPoint(); const topZ=end[2]; const baseZ=topZ-p.endH;
  const base=[end[0]-p.endW/2,end[1]-p.endD/2,baseZ];
  box(base[0],base[1],base[2],p.endW,p.endD,p.endH);
  box(end[0]-60,end[1]-60,topZ,120,120,pad1);
  box(end[0]-110,end[1]-110,topZ,220,220,pad2);
}
function drawGroundLine(){ if(!['FRONT','BACK','LEFT','RIGHT'].includes(viewMode)) return; ctx.save(); apply(); const p0=proj(0,0,0); ctx.strokeStyle='#c8c8c8'; ctx.lineWidth=1/scale; ctx.setLineDash([8/scale,6/scale]); ctx.beginPath(); ctx.moveTo(-1e5,p0[1]); ctx.lineTo(1e5,p0[1]); ctx.stroke(); ctx.setLineDash([]); ctx.restore(); }

/* ===== джойстик направления (ISO, только до разбиения) ===== */
const AXES=[
  {dir:'+Z',label:'+Z ↑',color:'#2aa14a',vec:[0,0,1]},
  {dir:'-Z',label:'-Z ↓',color:'#2aa14a',vec:[0,0,-1]},
  {dir:'+X',label:'+X →',color:'#e4463c',vec:[1,0,0]},
  {dir:'-X',label:'-X ←',color:'#e4463c',vec:[-1,0,0]},
  {dir:'+Y',label:'+Y ↗',color:'#2d6cdf',vec:[0,1,0]},
  {dir:'-Y',label:'-Y ↙',color:'#2d6cdf',vec:[0,-1,0]}
];
let hit=null,rays=[];
function placeGizmo(){ const [x,y]=proj(...endPoint()); const s=localToScreen(x,y); giz.style.left=s.x+'px'; giz.style.top=s.y+'px'; tag.style.left=s.x+'px'; tag.style.top=s.y+'px'; pop.style.left=s.x+'px'; pop.style.top=s.y+'px'; }
function drawArrow2D(p,q,color,thick,alpha,text){
  const [x1,y1]=p,[x2,y2]=q,a=Math.atan2(y2-y1,x2-x1),head=14;
  gz.strokeStyle=color; gz.globalAlpha=alpha; gz.lineWidth=thick; gz.lineCap='round';
  gz.beginPath(); gz.moveTo(x1,y1); gz.lineTo(x2-Math.cos(a)*head*0.92,y2-Math.sin(a)*head*0.92); gz.stroke();
  gz.beginPath(); gz.moveTo(x2,y2);
  gz.lineTo(x2-head*Math.cos(a-Math.PI/6),y2-head*Math.sin(a-Math.PI/6));
  gz.lineTo(x2-head*Math.cos(a+Math.PI/6),y2-head*Math.sin(a+Math.PI/6));
  gz.closePath(); gz.fillStyle=color; gz.fill();
  gz.globalAlpha=1; if(text){ gz.font='12px system-ui'; gz.fillStyle='#222'; gz.textAlign='center'; gz.fillText(text,x2,y2-6); }
}
function angleOf(vx,vy){ return Math.atan2(vy,vx); }
function angDiff(a,b){ let d=Math.abs(a-b)% (Math.PI*2); return d>Math.PI ? 2*Math.PI - d : d; }
function drawGizmo(){
  const size=giz.width,cx=size/2,cy=size/2; gz.clearRect(0,0,size,size);
  const base=endPoint(); rays=AXES.map(a=>{
    const tip=[base[0]+a.vec[0]*380,base[1]+a.vec[1]*380,base[2]+a.vec[2]*380];
    const O=proj(...base),T=proj(...tip); const v=[T[0]-O[0],T[1]-O[1]],len=Math.hypot(...v)||1,L=94;
    const to=[cx+v[0]/len*L, cy+v[1]/len*L];
    return {dir:a.dir,color:a.color,label:a.label,from:[cx,cy],to,phi:angleOf(to[0]-cx,to[1]-cy)};
  });
  gz.setLineDash([4,4]); gz.strokeStyle='#bdbdbd'; gz.beginPath(); gz.arc(cx,cy,100,0,Math.PI*2); gz.stroke(); gz.setLineDash([]);
  rays.forEach(r=>{
    const active = hit&&hit.dir===r.dir; const thick=active?7:4, alpha=(hit&&hit.dir!==r.dir)?0.35:0.98;
    drawArrow2D(r.from,r.to,r.color,thick,alpha,r.label);
  });
  gz.fillStyle='#000'; gz.beginPath(); gz.arc(cx,cy,3.6,0,Math.PI*2); gz.fill();
}
giz.addEventListener('pointermove',e=>{
  const rect=giz.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const cx=giz.width/2, cy=giz.height/2; const dx=x-cx, dy=y-cy; const r=Math.hypot(dx,dy);
  const phi=Math.atan2(dy,dx); const innerR=28, outerR=108;
  let found=null, best=1e9;
  for(const rr of rays){
    const ad=angDiff(phi, rr.phi);
    const within = (r>=innerR && r<=outerR && ad <= (18*Math.PI/180));
    const tipdx=x-rr.to[0], tipdy=y-rr.to[1], tipR=Math.hypot(tipdx,tipdy);
    const nearTip = tipR<=18;
    if(within || nearTip){
      const score = (nearTip?0:ad) + Math.abs(r-90)*0.001;
      if(score<best){ best=score; found=rr; }
    }
  }
  hit=found; tag.textContent='направление: '+(hit?hit.label:'—'); drawGizmo();
});
giz.addEventListener('pointerleave',()=>{ hit=null; tag.textContent='направление: —'; drawGizmo(); });
giz.addEventListener('click',()=>{ if(viewMode!=='ISO' || !hit || state.calc) return;
  if(state.segs.length){ const last=state.segs[state.segs.length-1];
    if(axis(last.dir)===axis(hit.dir)&&(sgn(last.dir)!==sgn(hit.dir))){
      msg.textContent='Нельзя идти назад по той же оси. Используйте «Отменить участок».';
      setTimeout(()=>msg.textContent='',1500); return;
    }
  }
  state.lastDir=hit.dir; showLenPopup();
});

/* ===== ввод/правка длин ===== */
function showLenPopup(){ hint.textContent=''; lenInput.value=window.__lastLen||''; pop.style.display='block'; setTimeout(()=>lenInput.focus(),0); }
function hideLenPopup(){ pop.style.display='none'; }
function commitLength(){
  let L=+lenInput.value;
  if(!(L>0)){ hint.textContent='Введите длину'; lenInput.focus(); return; }
  if(L<MIN_LEN){ hint.textContent=`Мин. длина ${MIN_LEN} мм`; lenInput.focus(); return; }
  window.__lastLen=L;
  if(state.segs.length&&state.segs[state.segs.length-1].dir===state.lastDir) state.segs[state.segs.length-1].len+=L;
  else state.segs.push({dir:state.lastDir,len:L});
  hideLenPopup(); draw();
}
okBtn.addEventListener('click', commitLength);
cancelBtn.addEventListener('click', hideLenPopup);
lenInput.addEventListener('keydown',e=>{ if(e.key==='Enter')commitLength(); if(e.key==='Escape')hideLenPopup(); });

function hideEdit(){ epop.style.display='none'; state.editingIdx=null; }
function updateEditPopupPosition(){
  if(epop.style.display!=='block' || state.editingIdx==null) return;
  const mid=segMid(state.editingIdx,true);
  epop.style.left=mid.x+'px'; epop.style.top=mid.y+'px';
}
function applyEdit(){
  const i=+(state.editingIdx==null?-1:state.editingIdx), v=+editInput.value;
  if(i<0||!(v>0)) return; if(v<MIN_LEN){ editInput.focus(); return; }
  state.segs[i].len=v; draw(); updateEditPopupPosition(); if(state.calc) renderSpec(); hideEdit();
}
document.getElementById('editOk').addEventListener('click', applyEdit);
document.getElementById('editCancel').addEventListener('click', hideEdit);
editInput.addEventListener('keydown',e=>{ if(e.key==='Enter')applyEdit(); if(e.key==='Escape')hideEdit(); });

/* ===== выноски: помноговидовые ===== */
let annoId=1;
function newEmptyPos(){ return {ax:0,ay:0,bx:0,by:0}; }
function ensureAnnoViewPos(anno, view){
  if(!anno.pos[view]){
    // если нет позиции для этого вида — копируем из ISO или из любого доступного
    const src = anno.pos[viewMode] || anno.pos.ISO || anno.pos.TOP || anno.pos.FRONT || anno.pos.LEFT || anno.pos.RIGHT || anno.pos.BACK;
    anno.pos[view] = src ? {...src} : newEmptyPos();
  }
  return anno.pos[view];
}
$('addAnno').addEventListener('click', ()=>{
  state.addAnnoMode=true;
  msg.textContent='Кликните в любом месте для кончика линии выноски (якорь).';
  setTimeout(()=>{ msg.textContent=''; }, 2500);
});
wrap.addEventListener('pointerdown', e=>{
  if(!state.addAnnoMode) return;
  const {x:ux,y:uy}=screenToLocal(e);
  const scr=localToScreen(ux,uy);
  apop.style.left=scr.x+'px'; apop.style.top=(scr.y-24)+'px'; ainput.value=''; apop.style.display='block'; setTimeout(()=>ainput.focus(),0);
  apop.dataset.ux=ux; apop.dataset.uy=uy; apop.dataset.view=viewMode;
  state.addAnnoMode=false;
});
aok.addEventListener('click', ()=>{
  const text=ainput.value.trim()||'Примечание';
  const ux=+apop.dataset.ux, uy=+apop.dataset.uy, vw=apop.dataset.view;
  const bx=ux + 60/scale, by=uy - 20/scale;
  const id=annoId++;
  const baseViewSet={ISO:newEmptyPos(),TOP:newEmptyPos(),FRONT:newEmptyPos(),BACK:newEmptyPos(),LEFT:newEmptyPos(),RIGHT:newEmptyPos()};
  baseViewSet[vw]={ax:ux,ay:uy,bx,by};
  const a={id, text, pos:baseViewSet, movingBox:false, movingAnchor:false};
  state.annos.push(a);
  apop.style.display='none'; draw();
});
acancel.addEventListener('click', ()=>{ apop.style.display='none'; });

function renderAnnos(){
  ctx.save(); ctx.setTransform(1,0,0,1,0,0);
  annoLayer.innerHTML='';
  state.annos.forEach(anno=>{
    const pv=ensureAnnoViewPos(anno, viewMode);
    const aScr=localToScreen(pv.ax, pv.ay);
    const bScr=localToScreen(pv.bx, pv.by);

    const anchor=document.createElement('div'); anchor.className='anchor-dot'+(anno.movingAnchor?' moving':'');
    anchor.style.left=(aScr.x-6)+'px'; anchor.style.top=(aScr.y-6)+'px'; anchor.dataset.id=anno.id;

    const box=document.createElement('div'); box.className='anno'+(anno.movingBox?' moving':''); box.textContent=anno.text;
    box.style.left=bScr.x+'px'; box.style.top=bScr.y+'px'; box.dataset.id=anno.id;

    annoLayer.appendChild(anchor); annoLayer.appendChild(box);

    const rect=box.getBoundingClientRect(), host=wrap.getBoundingClientRect();
    const cx = (rect.left - host.left) + rect.width/2;
    const cy = (rect.top  - host.top ) + rect.height/2;
    ctx.strokeStyle='#555'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(aScr.x, aScr.y); ctx.lineTo(cx, cy); ctx.stroke();

    box.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const a=state.annos.find(x=>x.id===+box.dataset.id);
      a.movingBox = !a.movingBox;
      if(a.movingBox){ a.movingAnchor=false; state.movingAnno={id:a.id,what:'box',view:viewMode}; }
      else { if(state.movingAnno.id===a.id && state.movingAnno.what==='box') state.movingAnno={id:null,what:null,view:null}; }
      draw();
    });
    box.addEventListener('dblclick', (ev)=>{
      ev.stopPropagation();
      const a=state.annos.find(x=>x.id===+box.dataset.id);
      ainput.value=a.text;
      apop.style.left=bScr.x+'px'; apop.style.top=(bScr.y-30)+'px'; apop.style.display='block';
      aok.onclick=()=>{ a.text=ainput.value.trim()||'Примечание'; apop.style.display='none'; draw(); };
      acancel.onclick=()=>{ apop.style.display='none'; };
    });

    anchor.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const a=state.annos.find(x=>x.id===+anchor.dataset.id);
      a.movingAnchor = !a.movingAnchor;
      if(a.movingAnchor){ a.movingBox=false; state.movingAnno={id:a.id,what:'anchor',view:viewMode}; }
      else { if(state.movingAnno.id===a.id && state.movingAnno.what==='anchor') state.movingAnno={id:null,what:null,view:null}; }
      draw();
    });
  });
  ctx.restore();
}

/* глобальное слежение за мышью для движущейся выноски (локальные координаты текущего вида) */
wrap.addEventListener('pointermove', (e)=>{
  const mv=state.movingAnno; if(!mv.id || !mv.what) return;
  const {x:ux,y:uy}=screenToLocal(e);
  const a=state.annos.find(z=>z.id===mv.id); if(!a) return;
  const pv=ensureAnnoViewPos(a, mv.view||viewMode);
  if(mv.what==='box'){ pv.bx=ux; pv.by=uy; }
  else if(mv.what==='anchor'){ pv.ax=ux; pv.ay=uy; }
  draw();
});
document.addEventListener('keydown', (e)=>{
  if(e.key==='Escape'){
    const mv=state.movingAnno;
    if(mv.id){ const a=state.annos.find(z=>z.id===mv.id); if(a){ a.movingBox=false; a.movingAnchor=false; } state.movingAnno={id:null,what:null,view:null}; draw(); }
  }
});

/* ===== кадр ===== */
function draw(){
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,cvs.width,cvs.height); ctx.restore();
  apply(); drawGroundLine(); drawStartCab(); drawPath(); drawEndCab(); drawEndCap(P().busW,P().busH);
  if(viewMode==='ISO' && !state.calc){ placeGizmo(); drawGizmo(); giz.style.display='block'; tag.style.display='block'; }
  else { giz.style.display='none'; tag.style.display='none'; pop.style.display='none'; }
  renderAnnos();
  updateEditPopupPosition();
}

/* ===== подгон/фуллскрин ===== */
function fit(){
  const p=P(); const pts=[];
  const topStart = originTop()[2], baseStart=topStart-p.startH;
  pts.push([0,0,baseStart],[p.startW,p.startD,topStart]);
  let pos=originTop(); pts.push(pos);
  for(const s of state.segs){ pos=adv(pos,s.dir,s.len|0); pts.push(pos); }
  const end=endPoint(); pts.push(end);
  const pad=400, MIN_SPAN=1000; const pr=pts.map(pt=>proj(...pt));
  const xs=pr.map(p=>p[0]), ys=pr.map(p=>p[1]);
  const minX=Math.min(...xs)-pad, maxX=Math.max(...xs)+pad, minY=Math.min(...ys)-pad, maxY=Math.max(...ys)+pad;
  const bwv=Math.max(maxX-minX, MIN_SPAN), bhv=Math.max(maxY-minY, MIN_SPAN), m=30;
  scale=Math.min((wrap.clientWidth-2*m)/bwv,(wrap.clientHeight-2*m)/bhv);
  panX=(wrap.clientWidth - scale*(minX+maxX))/2; panY=(wrap.clientHeight - scale*(minY+maxY))/2; draw();
}
$('fit').addEventListener('click', ()=>{ fit(); if(state.calc) renderSpec(); });
btnFS.addEventListener('click', ()=>{ const el=wrap, req=el.requestFullscreen||el.webkitRequestFullscreen||el.mozRequestFullScreen||el.msRequestFullscreen; const exit=document.exitFullscreen||document.webkitExitFullscreen||document.mozCancelFullScreen||document.msExitFullscreen; if(!(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement)){ req&&req.call(el); } else { exit&&exit.call(document); } setTimeout(()=>{ resize(); fit(); },120); });
$('saveImg').addEventListener('click', e=>{ e.preventDefault(); const url=cvs.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='nku_busway.png'; a.click(); });

/* ===== спецификация ===== */
function computeSpec(){
  const m=state.module|0, map=new Map(); let totalLen=0, jointsMod=0, mounts=0;
  let pos=originTop();
  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const startCut = prev ? elbowCuts(prev.dir, cur.dir).b : 0;
    const endCut   = next ? elbowCuts(cur.dir, next.dir).a : 0;
    const Ldraw=Math.max(0,L-startCut-endCut);

    totalLen+=L;
    const full=Math.floor(L/m), rem=L % m; if(full>0) map.set(m,(map.get(m)||0)+full); if(rem>0) map.set(rem,(map.get(rem)||0)+1);
    jointsMod += Math.max(0, full + (rem>0?1:0) - 1);
    mounts += mountPositionsForSegment(adv(pos,cur.dir,startCut), cur, Ldraw, startCut, endCut, prev, next, +$('mountStep').value||1000).length;

    pos=adv(pos,cur.dir,L);
  }
  let corners=0, vert=0, horiz=0;
  for(let i=1;i<state.segs.length;i++){ const a1=axis(state.segs[i-1].dir), a2=axis(state.segs[i].dir); if(a1!==a2){ corners++; if(a1==='Z'||a2==='Z') vert++; else horiz++; } }
  const nkuBlocks=( $('startType').value==='NKU'?1:0 ) + ( $('endType').value==='NKU'?1:0 );
  const trBlocks =( $('startType').value==='TR' ?1:0 ) + ( $('endType').value==='TR' ?1:0 );
  const jointsCorners=corners*2, jointsNku=nkuBlocks*1, jointsTr=trBlocks*1;
  const jointsTotal=jointsMod+jointsCorners+jointsNku+jointsTr;
  const endCap = $('endType').value==='ENDCAP' ? 1 : 0;
  return {module:m,totalLen,parts:map,joints:{total:jointsTotal,mod:jointsMod,corners:jointsCorners,nku:jointsNku,tr:jointsTr},vert,horiz,nkuBlocks,trBlocks,endCap,mounts};
}
function renderSpec(){
  const spec=$('spec');
  if(!state.calc){ spec.style.display='none'; return; }
  const sp=computeSpec(); spec.style.display='block';
  $('spHeader').textContent = `${$('mat').value==='CU'?'Cu':'Al'} / ${$('rating').value} A / ${$('ip').value}`;
  $('spModule').textContent = sp.module+' мм'; $('spTotalLen').textContent = sp.totalLen+' мм';
  $('spNkuBlocks').textContent = sp.nkuBlocks+' шт';
  $('spTrBlocks').textContent  = sp.trBlocks+' шт';
  $('spEndCap').textContent    = sp.endCap?'есть (1 шт)':'—';
  $('spJointsTotal').textContent=sp.joints.total+' шт'; $('spJointsMod').textContent=sp.joints.mod+' шт';
  $('spJointsCorners').textContent=sp.joints.corners+' шт'; $('spJointsNku').textContent=sp.joints.nku+' шт'; $('spJointsTr').textContent=sp.joints.tr+' шт';
  $('spVert').textContent=sp.vert+' шт'; $('spHoriz').textContent=sp.horiz+' шт';
  $('spMounts').textContent=sp.mounts+' шт';
  const tbody=$('spTable').querySelector('tbody'); tbody.innerHTML='';
  [...sp.parts.entries()].sort((a,b)=>b[0]-a[0]).forEach(([len,cnt])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${len}</td><td>${cnt}</td>`; tbody.appendChild(tr); });
}
$('saveCSV').addEventListener('click', ()=>{ if(!state.calc) return; const sp=computeSpec();
  const rows=[
    ['Материал',$('mat').value==='CU'?'Cu':'Al'],
    ['Номинал, A',$('rating').value],
    ['IP',$('ip').value],
    ['Модуль (мм)',sp.module],
    ['Итого длина (мм)',sp.totalLen],
    ['Блок к НКУ, шт',sp.nkuBlocks],
    ['Блок к ТР, шт',sp.trBlocks],
    ['Заглушка на конце',sp.endCap?1:0],
    ['Соединители всего, шт',sp.joints.total],
    ['— модульная разбивка, шт',sp.joints.mod],
    ['— на углах (по 2), шт',sp.joints.corners],
    ['— у подключения к НКУ, шт',sp.joints.nku],
    ['— у подключения к ТР, шт',sp.joints.tr],
    ['Повороты вертикальные, шт',sp.vert],
    ['Повороты горизонтальные, шт',sp.horiz],
    ['Крепления, шт',sp.mounts],
    [],
    ['Длина сегмента (мм)','Кол-во, шт']
  ];
  [...computeSpec().parts.entries()].sort((a,b)=>b[0]-a[0]).forEach(([len,cnt])=>rows.push([len,cnt]));
  const csv=rows.map(r=>r.join(';')).join('\n');
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='spec.csv'; a.click(); URL.revokeObjectURL(url);
});

/* ===== логика выбора типа/габаритов ===== */
function fillRatings(){ const sel=$('rating'); sel.innerHTML=''; const list=$('mat').value==='CU'?R_CU:R_AL; list.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); }); sel.value=list[0]; updateSection(); }
function updateSection(){ draw(); if(state.calc) renderSpec(); }
$('mat').addEventListener('change', fillRatings);
$('rating').addEventListener('change', updateSection);
$('startType').addEventListener('change', ()=>{
  const v=$('startType').value;
  if(v==='NKU'){ $('startW').value=600; $('startD').value=600; $('startH').value=2200; }
  else { $('startW').value=2000; $('startD').value=1400; $('startH').value=1700; }
  draw(); if(state.calc) renderSpec();
});
$('endType').addEventListener('change', ()=>{
  const v=$('endType').value;
  $('endDims').classList.toggle('hid', v!=='NKU');
  draw(); if(state.calc) renderSpec();
});
['startW','startD','startH','endW','endD','endH','ip','mountOn','mountStep','moduleLen']
  .forEach(id=>{ $(id).addEventListener('input', ()=>{ draw(); if(state.calc) renderSpec(); }); });

/* ===== разбиение/сброс ===== */
$('calc').addEventListener('click', ()=>{
  const m=+$('moduleLen').value||0;
  if(!(m>0)){ msg.textContent='Укажите длину модуля (>0)'; setTimeout(()=>msg.textContent='',1500); return; }
  state.module=m; state.calc=true;
  giz.style.display='none'; tag.style.display='none'; pop.style.display='none';
  draw(); renderSpec();
});
$('uncalc').addEventListener('click', ()=>{
  state.calc=false;
  draw(); renderSpec();
});
$('undo').addEventListener('click', ()=>{ state.segs.pop(); draw(); if(state.calc) renderSpec(); });
$('clear').addEventListener('click', ()=>{ state.segs.length=0; state.calc=false; draw(); renderSpec(); });

/* ===== старт ===== */
function start(){ fillRatings(); $('endDims').classList.add('hid'); resize(); setProjection('ISO'); }
start();

})();});
</script>
</html>
