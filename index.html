<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Шинопровод — чертёж, виды, спецификация, экспорт + цены</title>
<style>
  :root{--bg:#f6f6f6;--card:#fff;--border:#ddd;--shadow:0 6px 18px rgba(0,0,0,.06);--brand:#2d6cdf}
  html,body{margin:0;background:var(--bg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  header{max-width:1160px;margin:12px auto 8px;padding:0 16px}
  .wrap{max-width:1160px;margin:0 auto 20px;padding:0 16px;display:grid;grid-template-columns:420px 1fr;gap:16px}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:center;margin:10px 0}
  label{white-space:nowrap}
  input[type=number],select{width:100%;padding:8px 10px;border:1px solid #cfcfcf;border-radius:10px;background:#fafafa}
  .row-3{display:grid;grid-template-columns:repeat(3,minmax(56px,1fr));gap:8px;margin:6px 0}
  .row-3 input{min-width:56px;max-width:90px;padding:6px 8px;font-size:12px;line-height:1;height:26px;border:1px solid #cfcfcf;border-radius:10px;background:#fafafa}
  .btn{display:inline-block;padding:8px 12px;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
  .viewer{position:relative;background:#fff;border:1px solid var(--border);border-radius:12px;height:740px;overflow:hidden}
  .viewbar-top{position:absolute;left:8px;right:8px;top:8px;display:flex;gap:6px;z-index:12;justify-content:center;flex-wrap:wrap;user-select:none}
  .viewbar-bottom{position:absolute;left:8px;right:8px;bottom:8px;display:flex;gap:6px;z-index:12;justify-content:center;flex-wrap:wrap;user-select:none}
  .viewbtn{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#fff;cursor:pointer;box-shadow:var(--shadow);font-size:13px}
  .viewbtn.active{background:#eef3ff;border-color:#bcd}
  #view{width:100%;height:100%;display:block;background:#fff}
  #gizmo{position:absolute;width:220px;height:220px;transform:translate(-50%,-50%);pointer-events:auto;z-index:6}
  #tag{position:absolute;left:0;top:0;transform:translate(-50%,-110%);background:#fff;border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:12px;box-shadow:var(--shadow);z-index:7}
  .prompt{position:absolute;transform:translate(-50%,-100%);background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow);padding:10px;display:none;z-index:15}
  .warn{color:#c43;font-size:12px}
  .dim,.anno{position:absolute;pointer-events:auto;background:#fff;border:1px solid #ddd;border-radius:999px;padding:2px 8px;font-size:12px;box-shadow:var(--shadow);cursor:grab;user-select:none;z-index:10}
  .dim.dragging,.anno.dragging{cursor:grabbing;opacity:.96}
  .anchor-dot{position:absolute;width:12px;height:12px;border-radius:50%;background:#2d6cdf;border:2px solid #fff;box-shadow:var(--shadow);cursor:pointer;z-index:10}
  .hid{display:none}
  #spec{margin-top:10px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px}
  #spec h3{margin:0 0 6px;font-size:15px}
  .spec-row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:2px 0}
  .sub{color:#555}
  table{width:100%;border-collapse:collapse;margin-top:6px}
  th,td{padding:6px 8px;border-bottom:1px solid #eee;text-align:left}

  /* ===== цены: модалка ===== */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.4);display:none;align-items:center;justify-content:center;z-index:30}
  .modal.show{display:flex}
  .modal .card{width:min(980px,96vw);max-height:92vh;overflow:auto;background:#fff;border-radius:14px;border:1px solid #ddd;box-shadow:var(--shadow);padding:14px}
  .flex{display:flex;gap:8px;align-items:center}
  .pin{display:grid;grid-template-columns:1fr auto;gap:10px;margin:6px 0}
  textarea.price{width:100%;height:320px;font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,Monaco,monospace;border:1px solid #ccc;border-radius:8px;padding:8px;background:#fafafa;white-space:pre}
  .pill{display:inline-block;border:1px solid #ddd;background:#f7f7f7;border-radius:999px;padding:4px 8px;font-size:12px}
  .badge{display:inline-block;background:#eef3ff;color:#173b7a;border:1px solid #cfe; border-radius:999px;padding:2px 8px;font-size:12px;margin-left:6px}
  .price-box{margin-top:8px;border-top:1px dashed #e0e0e0;padding-top:8px}
</style>
</head>
<body>
<header><b>Шинопровод</b> — виды, размеры, спецификация, экспорт (PNG/DXF/XLS/PDF) + расчёт цены</header>

<div class="wrap">
  <div class="panel">
    <div class="row"><label>Материал шин</label>
      <select id="mat"><option value="AL" selected>Алюминий (Al)</option><option value="CU">Медь (Cu)</option></select>
    </div>
    <div class="row"><label>Номинальный ток, A</label><select id="rating"></select></div>
    <div class="row"><label>Степень защиты</label><select id="ip"><option>IP55</option><option>IP65</option></select></div>

    <div class="row"><label>Начало трассы</label>
      <select id="startType"><option value="NKU" selected>ГРЩ</option><option value="TR">Трансформатор</option></select>
    </div>
    <div class="row-3">
      <input id="startW" type="number" value="600"  title="Начало W" placeholder="W">
      <input id="startD" type="number" value="600"  title="Начало D" placeholder="D">
      <input id="startH" type="number" value="2200" title="Начало H" placeholder="H">
    </div>

    <div class="row"><label>Конец трассы</label>
      <select id="endType"><option value="ENDCAP" selected>Заглушка</option><option value="NKU">ГРЩ</option></select>
    </div>
    <div id="endDims" class="row-3 hid">
      <input id="endW" type="number" value="600"  title="Конец W" placeholder="W">
      <input id="endD" type="number" value="600"  title="Конец D" placeholder="D">
      <input id="endH" type="number" value="2200" title="Конец H" placeholder="H">
    </div>

    <div class="row"><label><b>Длина сегмента (модуль), мм</b></label><input id="moduleLen" type="number" value="3000"></div>

    <div class="row"><label>Крепления</label>
      <select id="mountOn"><option value="1" selected>есть</option><option value="0">нет</option></select>
    </div>
    <div class="row"><label>Целевой шаг крепления, мм</label><input id="mountStep" type="number" value="1000"></div>

    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="calc">Рассчитать разбиение</button>
      <button class="btn" id="uncalc">Отменить разбиение</button>
    </div>
    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="undo">Отменить участок</button>
      <button class="btn" id="clear">Сброс</button>
    </div>
    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="fit">Подогнать</button>
      <button class="btn" id="addAnno">➕ Выноска</button>
    </div>

    <div class="row" style="grid-template-columns:1fr 1fr">
      <button class="btn" id="saveProj">Сохранить проект</button>
      <button class="btn" id="loadProj">Загрузить проект</button>
      <input id="loadInput" type="file" accept="application/json" style="display:none">
    </div>

    <div id="msg" class="warn"></div>

    <div id="spec" style="display:none">
      <h3>Спецификация</h3>
      <div class="spec-row"><div>Материал / номинал / IP</div><div id="spHeader"></div></div>
      <div class="spec-row"><div>Модуль (стандартная длина)</div><div id="spModule"></div></div>
      <div class="spec-row"><div>Итого длина трассы</div><div id="spTotalLen"></div></div>
      <div class="spec-row"><div>Горизонтальные участки</div><div id="spLenHoriz"></div></div>
      <div class="spec-row"><div>Вертикально вверх</div><div id="spLenUp"></div></div>
      <div class="spec-row"><div>Вертикально вниз</div><div id="spLenDown"></div></div>
      <div class="spec-row"><div>Блок подключения к НКУ</div><div id="spNkuBlocks"></div></div>
      <div class="spec-row"><div>Блок подключения к ТР</div><div id="spTrBlocks"></div></div>
      <div class="spec-row"><div>Заглушка на конце</div><div id="spEndCap"></div></div>
      <div class="spec-row"><div>Соединители — всего</div><div id="spJointsTotal"></div></div>
      <div class="spec-row sub"><div>— модульная разбивка</div><div id="spJointsMod"></div></div>
      <div class="spec-row sub"><div>— на углах (по 2)</div><div id="spJointsCorners"></div></div>
      <div class="spec-row sub"><div>— у подключения к НКУ (по 1)</div><div id="spJointsNku"></div></div>
      <div class="spec-row sub"><div>— у подключения к ТР (по 1)</div><div id="spJointsTr"></div></div>
      <div class="spec-row"><div>Повороты: вертикальные</div><div id="spVert"></div></div>
      <div class="spec-row"><div>Повороты: горизонтальные</div><div id="spHoriz"></div></div>
      <div class="spec-row"><div>Крепления, шт</div><div id="spMounts"></div></div>
      <div style="margin:6px 0 2px;font-weight:600">Сегменты по длинам</div>
      <table id="spTable"><thead><tr><th>Длина, мм</th><th>Кол-во, шт</th></tr></thead><tbody></tbody></table>

      <h3 style="margin-top:14px">Стоимость (без НДС)</h3>
      <div class="spec-row"><div>Прямая секция (по метрам)</div><div id="costStraight"></div></div>
      <div class="spec-row"><div>Угловые секции</div><div id="costElbows"></div></div>
      <div class="spec-row"><div>Соединительные блоки</div><div id="costJoints"></div></div>
      <div class="spec-row"><div>Концевая заглушка</div><div id="costEndcap"></div></div>
      <div class="spec-row"><div>Подача питания (фланцевый блок)</div><div id="costFeeder"></div></div>
      <div class="spec-row"><div>Секция к трансформатору</div><div id="costTransformer"></div></div>
      <div class="spec-row"><div>Крепёж</div><div id="costMounts"></div></div>
      <div class="spec-row" style="font-weight:700"><div>ИТОГО</div><div id="costTotal"></div></div>

      <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn" id="saveCSV">Сохранить CSV</button>
      </div>
    </div>
  </div>

  <div class="viewer" id="wrap">
    <div class="viewbar-top">
      <button class="viewbtn active" data-view="ISO">Изометрия</button>
      <button class="viewbtn" data-view="TOP">Сверху</button>
      <button class="viewbtn" data-view="FRONT">Спереди</button>
      <button class="viewbtn" data-view="BACK">Сзади</button>
      <button class="viewbtn" data-view="LEFT">Слева</button>
      <button class="viewbtn" data-view="RIGHT">Справа</button>
    </div>

    <div class="viewbar-bottom">
      <button class="viewbtn" id="btnFS" title="Во весь экран">⛶</button>
      <button class="viewbtn" id="savePNG">PNG</button>
      <button class="viewbtn" id="savePNGAll">PNG все</button>
      <button class="viewbtn" id="saveDXF">DXF</button>
      <button class="viewbtn" id="saveXLS">XLS</button>
      <button class="viewbtn" id="savePDF">Проект (PDF)</button>
    </div>

    <canvas id="view"></canvas>
    <canvas id="gizmo" width="220" height="220"></canvas>
    <div id="tag">направление: —</div>

    <!-- ввод длины нового участка -->
    <div id="lenPopup" class="prompt">
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="lenInput" type="number" min="1" step="100" placeholder="длина, мм (≥400)">
        <div><button class="btn" id="ok">OK</button><button class="btn" id="cancel">Отмена</button></div>
      </div>
      <div class="warn" id="hint" style="margin-top:6px"></div>
    </div>

    <!-- правка длины -->
    <div id="editPopup" class="prompt">
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="editInput" type="number" min="1" step="100" placeholder="новая длина, мм (≥400)">
        <div><button class="btn" id="editOk">OK</button><button class="btn" id="editCancel">Отмена</button></div>
      </div>
    </div>

    <!-- ввод текста выноски -->
    <div id="annoPopup" class="prompt">
      <div class="row" style="grid-template-columns:1fr auto">
        <input id="annoInput" type="text" placeholder="текст выноски">
        <div><button class="btn" id="annoOk">OK</button><button class="btn" id="annoCancel">Отмена</button></div>
      </div>
    </div>

    <div id="dimLayer"></div>
    <div id="annoLayer"></div>
  </div>
</div>

<!-- ===== модалка цен (Alt+P) ===== -->
<div id="priceModal" class="modal" aria-hidden="true">
  <div class="card">
    <div class="flex" style="justify-content:space-between">
      <div><b>Прайс-конфигуратор</b> <span class="badge">Alt+P</span></div>
      <div class="pill">PIN-защита</div>
    </div>
    <div id="pinBlock" class="pin">
      <input id="pinInput" type="password" placeholder="Введите PIN" />
      <button class="btn" id="pinOk">Разблокировать</button>
    </div>
    <div id="priceBlock" class="hid">
      <div class="flex" style="justify-content:space-between;margin:6px 0">
        <div>Вставьте/правьте строки как в каталоге. Цена — <i>последнее число</i> в строке, копейки игнорируются.</div>
        <div class="pill" id="priceMeta"></div>
      </div>
      <textarea id="priceText" class="price"></textarea>
      <div class="price-box flex" style="justify-content:space-between;flex-wrap:wrap">
        <div class="flex" style="gap:6px">
          <button class="btn" id="priceImport">Импорт из текста</button>
          <button class="btn" id="priceSave">Сохранить</button>
          <button class="btn" id="priceExport">Экспорт текущих</button>
          <button class="btn" id="priceReset">Сбросить к заводским</button>
        </div>
        <div id="priceStats" class="pill"></div>
      </div>
    </div>
    <div class="flex" style="justify-content:flex-end;margin-top:8px">
      <button class="btn" id="priceClose">Закрыть</button>
    </div>
  </div>
</div>

<script>
/* ========= КОНСТАНТЫ/ВСПОМОГАТЕЛЬНЫЕ ========= */
const ADMIN_PIN='2468'; // поменяй при необходимости
const LS_PRICE_KEY='busway_prices_v1';
const DPR=Math.max(1,window.devicePixelRatio||1);
const ISO=Math.PI/6, C=Math.cos(ISO), S=Math.sin(ISO);

/* форматирование денег без копеек */
function money0(x){ x=Math.round(x||0); const s=x.toString(); return s.replace(/\B(?=(\d{3})+(?!\d))/g,' ')+' ₽'; }
function fmtNum(x){ return (x||0).toString().replace(/\B(?=(\d{3})+(?!\d))/g,' '); }

/* ========= ТВОИ ДАННЫЕ (ГЕОМЕТРИЯ И Т.П.) ========= */
const R_AL=[400,500,630,800,1000,1200,1250,1600,2000,2500,3200,4000,5000];
const R_CU=[400,500,630,800,1000,1200,1250,1600,2000,2500,3200,4000,5000,6300];
const WIDTH_AL={400:78,500:78,630:78,800:78,1000:100,1200:128,1250:128,1600:166,2000:205,2500:292,3200:368,4000:476,5000:560};
const WIDTH_CU={400:82,500:82,630:82,800:82,1000:120,1200:120,1250:120,1600:160,2000:220,2500:290,3200:360,4000:570,5000:570,6300:570};
const VERT_ELBOW={a:320,b:320};
const H_ELBOW_BY_R={400:[260,260],500:[260,260],630:[260,260],800:[260,260],1000:[270,270],1200:[290,290],1250:[290,290],1600:[310,310],2000:[220,220],2500:[370,370],3200:[410,410],4000:[460,450],5000:[500,500],6300:[500,500]};
const MIN_LEN=400, BUS_H=118;
const JOINT_LEN=100, JOINT_COLOR='rgb(52,168,83)', JOINT_A=0.55;
const MOUNT_ALONG=10, MOUNT_THICK=10, MOUNT_COLOR='rgba(255,140,0,.55)';
const SP_MIN=800, SP_MAX=1100;

/* ========= DOM ========= */
const $=id=>document.getElementById(id);
const wrap=$('wrap'), cvs=$('view'), ctx=cvs.getContext('2d');
const giz=$('gizmo'), gz=giz.getContext('2d'), tag=$('tag');
const dimLayer=document.getElementById('dimLayer'), annoLayer=document.getElementById('annoLayer');
const pop=$('lenPopup'), lenInput=$('lenInput'), hint=$('hint');
const epop=$('editPopup'), editInput=$('editInput');
const apop=$('annoPopup'), ainput=$('annoInput');
const msg=$('msg');

/* ========= ПРОЕКЦИЯ ========= */
let viewMode='ISO';
let proj=(x,y,z)=>[(x-y)*C,(x+y)*S - z];
function setProjection(mode){
  viewMode=mode;
  if(mode==='ISO') proj=(x,y,z)=>[(x-y)*C,(x+y)*S - z];
  if(mode==='TOP') proj=(x,y,z)=>[ x, -y ];
  if(mode==='FRONT') proj=(x,y,z)=>[ x, -z ];
  if(mode==='BACK') proj=(x,y,z)=>[ -x, -z ];
  if(mode==='LEFT') proj=(x,y,z)=>[ y, -z ];
  if(mode==='RIGHT') proj=(x,y,z)=>[ -y, -z ];
  document.querySelectorAll('.viewbtn[data-view]').forEach(b=>b.classList.toggle('active',b.dataset.view===mode));
  fit();
}
document.querySelectorAll('.viewbtn[data-view]').forEach(b=>b.addEventListener('click',()=>setProjection(b.dataset.view)));

let panX=0, panY=0, scale=1;
function apply(){ ctx.setTransform(DPR*scale,0,0,DPR*scale,panX*DPR,panY*DPR); }
function resize(){ cvs.width=Math.floor(wrap.clientWidth*DPR); cvs.height=Math.floor(wrap.clientHeight*DPR); draw(); }
addEventListener('resize', resize);

let dragging=false, sx=0, sy=0;
wrap.addEventListener('pointerdown',e=>{
  if(e.target.closest('#gizmo,.viewbar-top,.viewbar-bottom,.prompt,.anno,.dim,.anchor-dot')) return;
  dragging=true; sx=e.clientX; sy=e.clientY; wrap.setPointerCapture(e.pointerId);
});
wrap.addEventListener('pointermove',e=>{
  if(!dragging) return;
  panX+=e.clientX-sx; panY+=e.clientY-sy; sx=e.clientX; sy=e.clientY; draw(); updatePopups();
});
wrap.addEventListener('pointerup',()=>dragging=false);
wrap.addEventListener('wheel',e=>{
  e.preventDefault();
  const k=Math.exp(-e.deltaY*0.001), r=wrap.getBoundingClientRect();
  const mx=e.clientX-r.left, my=e.clientY-r.top;
  const zx=(mx-panX)/scale, zy=(my-panY)/scale;
  scale*=k; panX=mx-zx*scale; panY=my-zy*scale;
  draw(); updatePopups();
},{passive:false});
function localToScreen(u,v){ return {x:panX+scale*u, y:panY+scale*v}; }
function screenToLocal(e){ const r=wrap.getBoundingClientRect(); return {x:(e.clientX-r.left-panX)/scale, y:(e.clientY-r.top-panY)/scale}; }

/* ========= МОДЕЛЬ ========= */
const state={
  segs:[], lastDir:'+Z', calc:false, module:3000,
  dimOffsets:{ISO:{},TOP:{},FRONT:{},BACK:{},LEFT:{},RIGHT:{}},
  annos:[], movingAnno:{id:null,what:null,view:null}, editingIdx:null
};
const P=()=>({
  startType:$('startType').value, endType:$('endType').value,
  startW:+$('startW').value, startD:+$('startD').value, startH:+$('startH').value,
  endW:+$('endW').value, endD:+$('endD').value, endH:+$('endH').value,
  busW:( $('mat').value==='CU'?WIDTH_CU:WIDTH_AL )[+$('rating').value]||78,
  busH:BUS_H
});
function originTop(){ const p=P(); return [p.startW/2,p.startD/2,p.startH]; }
const axis=d=>d[1]; const sgn=d=>d[0]==='+'?1:-1;
const adv=(p,dir,dist)=>{ const a=axis(dir),s=sgn(dir); return a==='X'?[p[0]+s*dist,p[1],p[2]]:a==='Y'?[p[0],p[1]+s*dist,p[2]]:[p[0],p[1],p[2]+s*dist]; };
function endPoint(){ let [x,y,z]=originTop(); for(const s of state.segs){ const L=s.len|0; if(s.dir==='+X')x+=L; else if(s.dir==='-X')x-=L; if(s.dir==='+Y')y+=L; else if(s.dir==='-Y')y-=L; if(s.dir==='+Z')z+=L; else if(s.dir==='-Z')z-=L; } return [x,y,z]; }

/* ========= РИСОВАНИЕ ========= */
function line3(a,b,col='#111',lw=1/scale){ const p=proj(...a), q=proj(...b); ctx.lineWidth=lw; ctx.strokeStyle=col; ctx.beginPath(); ctx.moveTo(p[0],p[1]); ctx.lineTo(q[0],q[1]); ctx.stroke(); }
function fillPoly3(pts, fill, alpha){ const p=pts.map(v=>proj(...v)); ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=fill; ctx.beginPath(); ctx.moveTo(p[0][0],p[0][1]); for(let i=1;i<p.length;i++) ctx.lineTo(p[i][0],p[i][1]); ctx.closePath(); ctx.fill(); ctx.restore(); }
function box(x,y,z,w,d,h){ const v=[[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y+d,z],[x,y,z+h],[x+w,y,z+h],[x+w,y+d,z+h],[x,y+d,z+h]]; line3(v[0],v[4]); line3(v[1],v[5]); line3(v[2],v[6]); line3(v[3],v[7]); line3(v[4],v[5]); line3(v[5],v[6]); line3(v[6],v[7]); line3(v[7],v[4]); line3(v[0],v[1]); line3(v[1],v[2]); line3(v[2],v[3]); line3(v[3],v[0]); }
function solidBox(x,y,z,w,d,h,color='rgb(52,168,83)',alpha=.5){ const v=[[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y+d,z],[x,y,z+h],[x+w,y,z+h],[x+w,y+d,z+h],[x,y+d,z+h]]; const f=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]]; f.forEach(ff=>fillPoly3([v[ff[0]],v[ff[1]],v[ff[2]],v[ff[3]]],color,alpha)); [ [0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7] ].forEach(([a,b])=>line3(v[a],v[b]));
}
const VEC={X:[1,0,0],Y:[0,1,0],Z:[0,0,1]};
function dirVec(d){ const a=axis(d), s=sgn(d); const v=VEC[a]; return [v[0]*s,v[1]*s,v[2]*s]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function madd(o,u,su,v,sv,n,sn){ return [ o[0]+u[0]*su+v[0]*sv+n[0]*sn, o[1]+u[1]*su+v[1]*sv+n[1]*sn, o[2]+u[2]*su+v[2]*sv+n[2]*sn ]; }
function LpolyCornerSolid(lenA,lenB,half){ return [[-lenA,-half],[+half,-half],[+half,+lenB],[-half,+lenB],[-half,+half],[-lenA,+half]]; }
function extrudeSolid(poly, thick, O, U, V, N){ const t2=thick/2; const up=poly.map(p=>madd(O,U,p[0],V,p[1],N,+t2)); const dn=poly.map(p=>madd(O,U,p[0],V,p[1],N,-t2)); const color='rgb(60,110,220)', a=0.6; fillPoly3(dn,color,a); for(let i=0;i<up.length;i++){ const j=(i+1)%up.length; fillPoly3([up[i],up[j],dn[j],dn[i]],color,a);} fillPoly3(up,color,a); for(let i=0;i<up.length;i++){ line3(up[i], up[(i+1)%up.length]); line3(up[i], dn[i]); } }
function elbowCuts(d1,d2){ const a1=axis(d1), a2=axis(d2); if(a1===a2) return {a:0,b:0}; if(a1==='Z' || a2==='Z') return {...VERT_ELBOW}; const r=+$('rating').value, pair=H_ELBOW_BY_R[r]||[260,260]; return {a:pair[0], b:pair[1]}; }
function elbowSolidAtVertex(vertex, fromDir, toDir, aLen, bLen, bw, bh){ const U=dirVec(fromDir), V=dirVec(toDir), N=cross(U,V); const vertical=(axis(fromDir)==='Z'||axis(toDir)==='Z'); const thick = vertical ? bw : bh; const half  = vertical ? (bh/2) : (bw/2); const poly  = LpolyCornerSolid(aLen,bLen,half); extrudeSolid(poly, thick, vertex, U, V, N); }
function segBox(start,dir,L,bw,bh){
  const s=sgn(dir), a=axis(dir);
  if(a==='Z'){ const x=start[0]-bw/2, y=start[1]-bw/2, z=s>0?start[2]:start[2]-L; box(x,y,z,bw,bw,L); }
  if(a==='X'){ const x=s>0?start[0]:start[0]-L, y=start[1]-bw/2, z=start[2]-bh/2; box(x,y,z,L,bw,bh); }
  if(a==='Y'){ const x=start[0]-bw/2, y=s>0?start[1]:start[1]-L, z=start[2]-bh/2; box(x,y,z,bw,L,bh); }
}

/* соединители, крепления, шкафы */
function drawJointBlocksByModule(startPos, cur, Ldraw, startOffset, bw, bh){
  const m=state.module|0; if(!(m>0)) return;
  const full=Math.floor((cur.len|0)/m);
  for(let k=1;k<=full;k++){
    const d=k*m - startOffset; if(d<=0 || d>=Ldraw) continue;
    const p=adv(startPos,cur.dir,d); const a=axis(cur.dir);
    if(a==='Z') solidBox(p[0]-bw/2,p[1]-bw/2,p[2]-JOINT_LEN/2,bw,bw,JOINT_LEN,JOINT_COLOR,JOINT_A);
    if(a==='X') solidBox(p[0]-JOINT_LEN/2,p[1]-bw/2,p[2]-BUS_H/2,JOINT_LEN,bw,BUS_H,JOINT_COLOR,JOINT_A);
    if(a==='Y') solidBox(p[0]-bw/2,p[1]-JOINT_LEN/2,p[2]-BUS_H/2,bw,JOINT_LEN,BUS_H,JOINT_COLOR,JOINT_A);
  }
}
function intervalFill(a,b, haveA, haveB, target){
  const L=b-a, out=[]; if(L<=0) return out;
  function pushEven(n){ const step=L/(n+1); for(let i=1;i<=n;i++) out.push(a+i*step); }
  if(haveA&&haveB){ if(L<=SP_MAX) return out; let n=Math.ceil(L/SP_MAX)-1; while(L/(n+1)<SP_MIN&&n>0)n--; pushEven(n); return out; }
  if(!haveA&&!haveB){ if(L<SP_MIN) return out; let n=Math.round(L/Math.max(SP_MIN,Math.min(SP_MAX,target)))-1; if(n<0)n=0; while(L/(n+1)>SP_MAX)n++; while(L/(n+1)<SP_MIN&&n>0)n--; pushEven(n); return out; }
  let n=Math.round(L/Math.max(SP_MIN,Math.min(SP_MAX,target)))-1; if(n<0)n=0; while(L/(n+1)>SP_MAX)n++; while(L/(n+1)<SP_MIN&&n>0)n--; pushEven(n); return out;
}
function mountPositionsForSegment(startPos, cur, Ldraw, startCut, endCut, prev, next, target){
  const result=[]; if(axis(cur.dir)==='Z') return result;
  const hasA = !!(prev && axis(prev.dir)!==axis(cur.dir));
  const hasB = !!(next && axis(next.dir)!==axis(cur.dir));
  const anchors=[];
  if(hasA && Ldraw>=200) anchors.push(200);
  if(hasB && Ldraw>=200) anchors.push(Ldraw-200);
  anchors.sort((a,b)=>a-b);
  if(anchors.length===0){ result.push(...intervalFill(0,Ldraw,false,false,target)); }
  else{
    result.push(...intervalFill(0,anchors[0],false,true,target));
    for(let i=0;i<anchors.length-1;i++){
      result.push(anchors[i], ...intervalFill(anchors[i],anchors[i+1],true,true,target));
    }
    const last=anchors[anchors.length-1];
    result.push(last, ...intervalFill(last,Ldraw,true,false,target));
  }
  const uniq=[], seen=new Set();
  for(const d of result){ const v=Math.max(0,Math.min(Ldraw,d)); const k=v.toFixed(2); if(!seen.has(k)){ seen.add(k); uniq.push(v); } }
  return uniq;
}
function drawMountsSmart(startPos, cur, Ldraw, startCut, endCut, prev, next, bw){
  if($('mountOn').value!=='1') return 0;
  const arr=mountPositionsForSegment(startPos,cur,Ldraw,startCut,endCut,prev,next,+$('mountStep').value||1000);
  for(const d of arr){
    const C=adv(startPos,cur.dir,d);
    if(axis(cur.dir)==='X'){
      const x0=C[0]-MOUNT_ALONG/2, y0=C[1]-bw/2, z0=C[2]-BUS_H/2-MOUNT_THICK;
      solidBox(x0,y0,z0,MOUNT_ALONG,bw,MOUNT_THICK,MOUNT_COLOR,1);
    }else if(axis(cur.dir)==='Y'){
      const y0=C[1]-MOUNT_ALONG/2, x0=C[0]-bw/2, z0=C[2]-BUS_H/2-MOUNT_THICK;
      solidBox(x0,y0,z0,bw,MOUNT_ALONG,MOUNT_THICK,MOUNT_COLOR,1);
    }
  }
  return arr.length;
}
function drawStartCab(){ const p=P(); const top=originTop()[2], base=top-p.startH; box(0,0,base,p.startW,p.startD,p.startH); box(p.startW/2-60,p.startD/2-60,top,120,120,8); box(p.startW/2-110,p.startD/2-110,top,220,220,4); }
function drawEndCab(){ if($('endType').value!=='NKU') return; const p=P(), end=endPoint(), top=end[2], base=top-p.endH; box(end[0]-p.endW/2,end[1]-p.endD/2,base,p.endW,p.endD,p.endH); box(end[0]-60,end[1]-60,top,120,120,8); box(end[0]-110,end[1]-110,top,220,220,4); }
function drawEndCap(bw){ if($('endType').value!=='ENDCAP') return; const end=endPoint(); const last=state.segs[state.segs.length-1]||{dir:'+Z'}; const a=axis(last.dir); if(a==='Z') solidBox(end[0]-bw/2,end[1]-bw/2,end[2]-JOINT_LEN/2,bw,bw,JOINT_LEN,'rgba(220,0,0,.55)',1); if(a==='X') solidBox(end[0]-JOINT_LEN/2,end[1]-bw/2,end[2]-BUS_H/2,JOINT_LEN,bw,BUS_H,'rgba(220,0,0,.55)',1); if(a==='Y') solidBox(end[0]-bw/2,end[1]-JOINT_LEN/2,end[2]-BUS_H/2,bw,JOINT_LEN,BUS_H,'rgba(220,0,0,.55)',1); }
function getDimOffset(key){ return state.dimOffsets[viewMode][key]||{dx:0,dy:0}; }
function setDimOffset(key,dx,dy){ state.dimOffsets[viewMode][key]={dx,dy}; }

/* ========= ТРАССА ========= */
function drawPath(){
  const prm=P(), bw=prm.busW, bh=prm.busH;
  let pos=originTop(); dimLayer.innerHTML='';
  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const sc=prev?elbowCuts(prev.dir,cur.dir).b:0;
    const ec=next?elbowCuts(cur.dir,next.dir).a:0;
    const startPos=adv(pos,cur.dir,sc);
    const Ldraw=Math.max(0,L-sc-ec);
    if(Ldraw>0){
      segBox(startPos,cur.dir,Ldraw,bw,bh);
      if(state.calc){
        drawJointBlocksByModule(startPos,cur,Ldraw,sc,bw,bh);
        drawMountsSmart(startPos,cur,Ldraw,sc,ec,prev,next,bw);
      }
      const mid=adv(startPos,cur.dir,Ldraw/2); const p2=proj(...mid); const base=localToScreen(p2[0],p2[1]);
      const label=(axis(cur.dir)==='Z'?'H':'L')+' = '+L+' мм';
      const key=i; const off=getDimOffset(key); const x=base.x+(off.dx||0), y=base.y+(off.dy||0);
      if(state.calc){
        const el=document.createElement('div'); el.className='dim'; el.textContent=label; el.dataset.idx=i; el.style.left=x+'px'; el.style.top=y+'px';
        let drag=false, sx=0, sy=0, dx0=off.dx||0, dy0=off.dy||0;
        el.addEventListener('pointerdown',e=>{ drag=true; el.classList.add('dragging'); sx=e.clientX; sy=e.clientY; el.setPointerCapture(e.pointerId); });
        el.addEventListener('pointermove',e=>{ if(!drag) return; const dx=e.clientX-sx, dy=e.clientY-sy; el.style.left=(base.x+dx0+dx)+'px'; el.style.top=(base.y+dy0+dy)+'px'; });
        el.addEventListener('pointerup',()=>{ if(!drag) return; drag=false; el.classList.remove('dragging'); const dx=parseFloat(el.style.left)-base.x; const dy=parseFloat(el.style.top)-base.y; setDimOffset(key,dx,dy); });
        el.addEventListener('dblclick',ev=>{ ev.stopPropagation(); openEdit(i); });
        dimLayer.appendChild(el);
      }
    }
    if(ec>0 && next){
      const cuts=elbowCuts(cur.dir,next.dir);
      const vertex=adv(pos,cur.dir,L);
      elbowSolidAtVertex(vertex,cur.dir,next.dir,cuts.a,cuts.b,bw,bh);
    }
    pos=adv(pos,cur.dir,L);
  }
  renderDeltaH();
}
function renderDeltaH(){
  if(!['FRONT','BACK','LEFT','RIGHT'].includes(viewMode)) return;
  if($('endType').value!=='NKU') return;
  const p=P(); const sTop=originTop()[2], sBase=sTop-p.startH; const eTop=endPoint()[2], eBase=eTop-p.endH;
  const delta=Math.abs(eBase-sBase)|0;
  const sPt=proj(p.startW/2,p.startD/2,sBase);
  const ePt=proj(endPoint()[0],endPoint()[1],eBase);
  const mid={u:(sPt[0]+ePt[0])/2, v:(sPt[1]+ePt[1])/2};
  const base=localToScreen(mid.u,mid.v);
  const off=getDimOffset('__deltaH'); const x=base.x+(off.dx||0), y=base.y+(off.dy||0);
  const el=document.createElement('div'); el.className='dim'; el.textContent=`ΔH = ${delta} мм`; el.style.left=x+'px'; el.style.top=y+'px';
  let drag=false, sx=0, sy=0, dx0=off.dx||0, dy0=off.dy||0;
  el.addEventListener('pointerdown',e=>{ drag=true; el.classList.add('dragging'); sx=e.clientX; sy=e.clientY; el.setPointerCapture(e.pointerId); });
  el.addEventListener('pointermove',e=>{ if(!drag) return; const dx=e.clientX-sx, dy=e.clientY-sy; el.style.left=(base.x+dx0+dx)+'px'; el.style.top=(base.y+dy0+dy)+'px'; });
  el.addEventListener('pointerup',()=>{ if(!drag) return; drag=false; el.classList.remove('dragging'); const dx=parseFloat(el.style.left)-base.x; const dy=parseFloat(el.style.top)-base.y; setDimOffset('__deltaH',dx,dy); });
  dimLayer.appendChild(el);
}

/* ========= ДЖОЙСТИК НАПРАВЛЕНИЙ ========= */
const AXES=[{dir:'+Z',label:'+Z ↑',color:'#2aa14a',vec:[0,0,1]},{dir:'-Z',label:'-Z ↓',color:'#2aa14a',vec:[0,0,-1]},{dir:'+X',label:'+X →',color:'#e4463c',vec:[1,0,0]},{dir:'-X',label:'-X ←',color:'#e4463c',vec:[-1,0,0]},{dir:'+Y',label:'+Y ↗',color:'#2d6cdf',vec:[0,1,0]},{dir:'-Y',label:'-Y ↙',color:'#2d6cdf',vec:[0,-1,0]}];
let hit=null, rays=[];
function placeGizmo(){ const [x,y]=proj(...endPoint()); const s=localToScreen(x,y); giz.style.left=s.x+'px'; giz.style.top=s.y+'px'; tag.style.left=s.x+'px'; tag.style.top=s.y+'px'; pop.style.left=s.x+'px'; pop.style.top=s.y+'px'; }
function drawArrow2D(p,q,color,thick,alpha,text){ const [x1,y1]=p,[x2,y2]=q,a=Math.atan2(y2-y1,x2-x1),head=14; gz.strokeStyle=color; gz.globalAlpha=alpha; gz.lineWidth=thick; gz.lineCap='round'; gz.beginPath(); gz.moveTo(x1,y1); gz.lineTo(x2-Math.cos(a)*head*0.92,y2-Math.sin(a)*head*0.92); gz.stroke(); gz.beginPath(); gz.moveTo(x2,y2); gz.lineTo(x2-head*Math.cos(a-Math.PI/6),y2-head*Math.sin(a-Math.PI/6)); gz.lineTo(x2-head*Math.cos(a+Math.PI/6),y2-head*Math.sin(a+Math.PI/6)); gz.closePath(); gz.fillStyle=color; gz.fill(); gz.globalAlpha=1; gz.font='12px system-ui'; gz.fillStyle='#222'; gz.textAlign='center'; gz.fillText(text,x2,y2-6); }
function angleOf(vx,vy){return Math.atan2(vy,vx)}; function angDiff(a,b){let d=Math.abs(a-b)%(Math.PI*2);return d>Math.PI?2*Math.PI-d:d;}
function drawGizmo(){ const size=giz.width,cx=size/2,cy=size/2; gz.clearRect(0,0,size,size); const base=endPoint(); rays=AXES.map(a=>{ const tip=[base[0]+a.vec[0]*380,base[1]+a.vec[1]*380,base[2]+a.vec[2]*380]; const O=proj(...base),T=proj(...tip); const v=[T[0]-O[0],T[1]-O[1]],len=Math.hypot(...v)||1,L=94; const to=[cx+v[0]/len*L, cy+v[1]/len*L]; return {dir:a.dir,color:a.color,label:a.label,from:[cx,cy],to,phi:angleOf(to[0]-cx,to[1]-cy)}; }); gz.setLineDash([4,4]); gz.strokeStyle='#bdbdbd'; gz.beginPath(); gz.arc(cx,cy,100,0,Math.PI*2); gz.stroke(); gz.setLineDash([]); rays.forEach(r=>{ const active=hit&&hit.dir===r.dir; drawArrow2D(r.from,r.to,r.color,active?7:4,active?1:.95,r.label); }); gz.fillStyle='#000'; gz.beginPath(); gz.arc(cx,cy,3.6,0,Math.PI*2); gz.fill(); }
giz.addEventListener('pointermove',e=>{ const rect=giz.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top; const cx=giz.width/2, cy=giz.height/2, dx=x-cx, dy=y-cy, r=Math.hypot(dx,dy), phi=Math.atan2(dy,dx), innerR=28, outerR=108; let found=null,best=1e9; for(const rr of rays){ const ad=angDiff(phi,rr.phi); const within=(r>=innerR&&r<=outerR&&ad<=18*Math.PI/180); const tipR=Math.hypot(x-rr.to[0],y-rr.to[1]); const nearTip=tipR<=18; if(within||nearTip){ const score=(nearTip?0:ad)+Math.abs(r-90)*0.001; if(score<best){best=score;found=rr;} } } hit=found; tag.textContent='направление: '+(hit?hit.label:'—'); drawGizmo(); });
giz.addEventListener('pointerleave',()=>{ hit=null; tag.textContent='направление: —'; drawGizmo(); });
giz.addEventListener('click',()=>{ if(viewMode!=='ISO'||!hit||state.calc) return; if(state.segs.length){ const last=state.segs[state.segs.length-1]; if(axis(last.dir)===axis(hit.dir)&&(sgn(last.dir)!==sgn(hit.dir))){ msg.textContent='Нельзя идти назад по той же оси'; setTimeout(()=>msg.textContent='',1500); return; } } state.lastDir=hit.dir; showLenPopup(); });

/* ===== ввод длин ===== */
function showLenPopup(){ $('hint').textContent=''; $('lenInput').value=window.__lastLen||''; pop.style.display='block'; setTimeout(()=>$('lenInput').focus(),0); }
function hideLenPopup(){ pop.style.display='none'; }
$('ok').onclick=commitLength; $('cancel').onclick=hideLenPopup;
lenInput.addEventListener('keydown',e=>{ if(e.key==='Enter')commitLength(); if(e.key==='Escape')hideLenPopup(); });
function commitLength(){ let L=+$('lenInput').value; if(!(L>0)){ hint.textContent='Введите длину'; return; } if(L<MIN_LEN){ hint.textContent=`Мин. длина ${MIN_LEN} мм`; return; } window.__lastLen=L; if(state.segs.length&&state.segs[state.segs.length-1].dir===state.lastDir) state.segs[state.segs.length-1].len+=L; else state.segs.push({dir:state.lastDir,len:L}); hideLenPopup(); draw(); }

/* правка длины сегмента */
function openEdit(i){ state.editingIdx=i; const mid=segMid(i,true); epop.style.left=mid.x+'px'; epop.style.top=mid.y+'px'; $('editInput').value=state.segs[i].len|0; epop.style.display='block'; setTimeout(()=>$('editInput').focus(),0); }
$('editOk').onclick=applyEdit; $('editCancel').onclick=()=>epop.style.display='none';
editInput.addEventListener('keydown',e=>{ if(e.key==='Enter')applyEdit(); if(e.key==='Escape')epop.style.display='none'; });
function applyEdit(){ const i=+(state.editingIdx==null?-1:state.editingIdx), v=+$('editInput').value; if(i<0||!(v>0)) return; if(v<MIN_LEN) return; state.segs[i].len=v; epop.style.display='none'; draw(); if(state.calc) renderSpec(); }
function updatePopups(){ if(epop.style.display==='block' && state.editingIdx!=null){ const p=segMid(state.editingIdx,true); epop.style.left=p.x+'px'; epop.style.top=p.y+'px'; } }

/* выбор сегмента кликом */
cvs.addEventListener('click',e=>{
  const pick=pickSegByPoint(e,false);
  if(pick.idx<0) return;
  openEdit(pick.idx);
});
function distPointSeg(px,py,x1,y1,x2,y2){ const vx=x2-x1,vy=y2-y1,wx=px-x1,wy=py-y1; const t=Math.max(0,Math.min(1,(vx*wx+vy*wy)/(vx*vx+vy*vy||1))); const dx=x1+t*vx-px, dy=y1+t*vy-py; return {d:Math.hypot(dx,dy),t}; }
function pickSegByPoint(e,useCuts){
  const r=wrap.getBoundingClientRect(); const lx=(e.clientX-r.left-panX)/scale, ly=(e.clientY-r.top-panY)/scale;
  let pos=originTop(), idx=-1, best=1e9, bestT=0;
  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const sc=useCuts&&prev?elbowCuts(prev.dir,cur.dir).b:0, ec=useCuts&&next?elbowCuts(cur.dir,next.dir).a:0;
    const start=adv(pos,cur.dir,sc), Ldraw=Math.max(0,L-sc-ec);
    const p1=proj(...start), p2=proj(...adv(start,cur.dir,Ldraw));
    const r2=distPointSeg(lx,ly,p1[0],p1[1],p2[0],p2[1]);
    if(r2.d<18/scale && r2.d<best){ best=r2.d; idx=i; bestT=sc+r2.t*Ldraw; }
    pos=adv(pos,cur.dir,L);
  }
  return {idx,along:bestT};
}
function segMid(i,withCuts){
  let pos=originTop();
  for(let k=0;k<state.segs.length;k++){
    const cur=state.segs[k], L=cur.len|0, prev=state.segs[k-1], next=state.segs[k+1];
    const sc=withCuts&&prev?elbowCuts(prev.dir,cur.dir).b:0, ec=withCuts&&next?elbowCuts(cur.dir,next.dir).a:0;
    const start=adv(pos,cur.dir,sc), Ldraw=Math.max(0,L-sc-ec);
    if(k===i){ const mid=adv(start,cur.dir,Ldraw/2); const p2=proj(...mid); return localToScreen(p2[0],p2[1]); }
    pos=adv(pos,cur.dir,L);
  }
  return {x:panX,y:panY};
}

/* ====== выноски ====== */
let annoId=1;
function newPos(){ return {ax:0,ay:0,bx:0,by:0}; }
function ensurePos(anno,view){ if(!anno.pos[view]){ const src=anno.pos[viewMode]||anno.pos.ISO||newPos(); anno.pos[view]={...src}; } return anno.pos[view]; }
$('addAnno').addEventListener('click',()=>{ state.addAnno=true; msg.textContent='Кликните место якоря выноски'; setTimeout(()=>msg.textContent='',1500); });
wrap.addEventListener('pointerdown',e=>{
  if(!state.addAnno) return;
  const {x:ux,y:uy}=screenToLocal(e); const scr=localToScreen(ux,uy);
  apop.style.left=scr.x+'px'; apop.style.top=(scr.y-24)+'px'; apop.style.display='block';
  ainput.value=''; apop.dataset.ux=ux; apop.dataset.uy=uy; apop.dataset.view=viewMode; state.addAnno=false;
});
$('annoOk').onclick=()=>{ const text=ainput.value.trim()||'Примечание'; const ux=+apop.dataset.ux, uy=+apop.dataset.uy, vw=apop.dataset.view; const bx=ux+60/scale, by=uy-20/scale; const id=annoId++; const base={ISO:newPos(),TOP:newPos(),FRONT:newPos(),BACK:newPos(),LEFT:newPos(),RIGHT:newPos()}; base[vw]={ax:ux,ay:uy,bx,by}; state.annos.push({id,text,pos:base,movingBox:false,movingAnchor:false}); apop.style.display='none'; draw(); };
$('annoCancel').onclick=()=>apop.style.display='none';
function renderAnnos(){
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); annoLayer.innerHTML='';
  state.annos.forEach(a=>{
    const pv=ensurePos(a,viewMode); const aScr=localToScreen(pv.ax,pv.ay), bScr=localToScreen(pv.bx,pv.by);
    const anchor=document.createElement('div'); anchor.className='anchor-dot'; anchor.style.left=(aScr.x-6)+'px'; anchor.style.top=(aScr.y-6)+'px'; anchor.dataset.id=a.id;
    const box=document.createElement('div'); box.className='anno'; box.textContent=a.text; box.style.left=bScr.x+'px'; box.style.top=bScr.y+'px'; box.dataset.id=a.id;
    annoLayer.appendChild(anchor); annoLayer.appendChild(box);
    const rect=box.getBoundingClientRect(), host=wrap.getBoundingClientRect(); const cx=(rect.left-host.left)+rect.width/2, cy=(rect.top-host.top)+rect.height/2;
    ctx.strokeStyle='#555'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(aScr.x,aScr.y); ctx.lineTo(cx,cy); ctx.stroke();
    box.addEventListener('click',ev=>{ ev.stopPropagation(); a.movingBox=!a.movingBox; if(a.movingBox){ a.movingAnchor=false; state.movingAnno={id:a.id,what:'box',view:viewMode}; } else state.movingAnno={id:null,what:null,view:null}; draw(); });
    box.addEventListener('dblclick',ev=>{ ev.stopPropagation(); ainput.value=a.text; const p=localToScreen(pv.bx,pv.by); apop.style.left=p.x+'px'; apop.style.top=(p.y-26)+'px'; apop.style.display='block'; $('annoOk').onclick=()=>{ a.text=ainput.value.trim()||'Примечание'; apop.style.display='none'; draw(); }; $('annoCancel').onclick=()=>apop.style.display='none'; });
    anchor.addEventListener('click',ev=>{ ev.stopPropagation(); a.movingAnchor=!a.movingAnchor; if(a.movingAnchor){ a.movingBox=false; state.movingAnno={id:a.id,what:'anchor',view:viewMode}; } else state.movingAnno={id:null,what:null,view:null}; draw(); });
  }); ctx.restore();
}
wrap.addEventListener('pointermove',e=>{
  const mv=state.movingAnno; if(!mv.id||!mv.what) return;
  const a=state.annos.find(x=>x.id===mv.id); if(!a) return;
  const pv=ensurePos(a,mv.view||viewMode); const {x,y}=screenToLocal(e);
  if(mv.what==='box'){ pv.bx=x; pv.by=y; } else { pv.ax=x; pv.ay=y; }
  draw();
});
document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){ const mv=state.movingAnno; if(mv.id){ const a=state.annos.find(t=>t.id===mv.id); if(a){ a.movingBox=false; a.movingAnchor=false; } state.movingAnno={id:null,what:null,view:null}; draw(); } }
});

/* ========= кадр/подгон ========= */
function draw(){
  ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,cvs.width,cvs.height); ctx.restore();
  apply(); drawStartCab(); drawPath(); drawEndCab(); drawEndCap(P().busW);
  if(viewMode==='ISO' && !state.calc){ placeGizmo(); drawGizmo(); giz.style.display='block'; tag.style.display='block'; } else { giz.style.display='none'; tag.style.display='none'; pop.style.display='none'; }
  renderAnnos(); updatePopups();
}
function fit(){
  const p=P(); const pts=[[0,0,originTop()[2]-p.startH],[p.startW,p.startD,originTop()[2]]]; let pos=originTop(); pts.push(pos);
  for(const s of state.segs){ pos=adv(pos,s.dir,s.len|0); pts.push(pos); }
  if($('endType').value==='NKU'){ const e=endPoint(); pts.push([e[0]-p.endW/2,e[1]-p.endD/2,e[2]-p.endH]); pts.push([e[0]+p.endW/2,e[1]+p.endD/2,e[2]]); }
  const pr=pts.map(pt=>proj(...pt)); const xs=pr.map(p=>p[0]), ys=pr.map(p=>p[1]);
  const minX=Math.min(...xs)-300, maxX=Math.max(...xs)+300, minY=Math.min(...ys)-300, maxY=Math.max(...ys)+300;
  const m=30, bw=maxX-minX, bh=maxY-minY;
  scale=Math.min((wrap.clientWidth-2*m)/Math.max(bw,800),(wrap.clientHeight-2*m)/Math.max(bh,600));
  panX=(wrap.clientWidth - scale*(minX+maxX))/2; panY=(wrap.clientHeight - scale*(minY+maxY))/2;
  draw();
}

/* ========= DXF/XLS/PDF/PNG ========= */
/* ... (DXF и PNG — как раньше, без изменений по логике; ради длины ответа пропускаю комментарии) */
function computeDimBadges(){
  const out=[]; const prm=P(), bw=prm.busW, bh=prm.busH; let pos=originTop();
  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const sc=prev?elbowCuts(prev.dir,cur.dir).b:0, ec=next?elbowCuts(cur.dir,next.dir).a:0;
    const start=adv(pos,cur.dir,sc), Ldraw=Math.max(0,L-sc-ec);
    if(Ldraw>0){ const mid=adv(start,cur.dir,Ldraw/2); const p2=proj(...mid); const base=localToScreen(p2[0],p2[1]); const off=getDimOffset(i); const prefix=(axis(cur.dir)==='Z')?'H':'L'; out.push({text:`${prefix} = ${L} мм`, x:base.x+(off.dx||0), y:base.y+(off.dy||0)}); }
    pos=adv(pos,cur.dir,L);
  }
  if(['FRONT','BACK','LEFT','RIGHT'].includes(viewMode) && $('endType').value==='NKU'){
    const p=P(); const sTop=originTop()[2], sBase=sTop-p.startH, eTop=endPoint()[2], eBase=eTop-p.endH, delta=Math.abs(eBase-sBase)|0;
    const sPt=proj(p.startW/2,p.startD/2,sBase), ePt=proj(endPoint()[0],endPoint()[1],eBase);
    const mid={u:(sPt[0]+ePt[0])/2, v:(sPt[1]+ePt[1])/2}; const base=localToScreen(mid.u,mid.v); const off=getDimOffset('__deltaH');
    out.push({text:`ΔH = ${delta} мм`, x:base.x+(off.dx||0), y:base.y+(off.dy||0)});
  }
  return out;
}
function roundedPath(g,x,y,w,h,r){ g.beginPath(); g.moveTo(x+r,y); g.arcTo(x+w,y,x+w,y+h,r); g.arcTo(x+w,y+h,x,y+h,r); g.arcTo(x,y+h,x,y,r); g.arcTo(x,y,x+w,y,r); g.closePath(); }
function snapshotPNG(returnCanvas=false){
  const off=document.createElement('canvas'); off.width=cvs.width; off.height=cvs.height; const g=off.getContext('2d');
  g.fillStyle='#fff'; g.fillRect(0,0,off.width,off.height); g.drawImage(cvs,0,0);
  const badges=computeDimBadges(); g.font='13px system-ui'; g.textBaseline='middle';
  badges.forEach(b=>{ const pad=10,h=24,w=g.measureText(b.text).width+2*pad,x=b.x-w/2,y=b.y-h/2; g.fillStyle='#fff'; g.strokeStyle='#ddd'; g.lineWidth=1; roundedPath(g,x,y,w,h,12); g.fill(); g.stroke(); g.fillStyle='#111'; g.fillText(b.text,b.x-(w-2*pad)/2,b.y); });
  state.annos.forEach(a=>{ const pv=a.pos[viewMode]||a.pos.ISO||newPos(); const A=localToScreen(pv.ax,pv.ay), B=localToScreen(pv.bx,pv.by); const txt=a.text||'Примечание'; const pad=10,h=24,m=g.measureText(txt).width,w=m+2*pad,x=B.x,y=B.y; g.fillStyle='#fff'; g.strokeStyle='#ddd'; g.lineWidth=1; roundedPath(g,x,y,w,h,12); g.fill(); g.stroke(); g.fillStyle='#111'; g.fillText(txt,x+pad,y+h/2); const cx=x+w/2,cy=y+h/2; g.strokeStyle='#555'; g.lineWidth=1; g.beginPath(); g.moveTo(A.x,A.y); g.lineTo(cx,cy); g.stroke(); g.fillStyle='#2d6cdf'; g.beginPath(); g.arc(A.x,A.y,4,0,Math.PI*2); g.fill(); g.strokeStyle='#fff'; g.lineWidth=2; g.stroke(); });
  return returnCanvas?off:off.toDataURL('image/png');
}
$('savePNG').onclick=()=>{ const off=snapshotPNG(true); off.toBlob(b=>{ const url=URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; a.download=`view_${viewMode}.png`; a.click(); URL.revokeObjectURL(url); },'image/png'); };
$('savePNGAll').onclick=async ()=>{ const orig=viewMode, views=['ISO','TOP','FRONT','BACK','LEFT','RIGHT']; for(const v of views){ setProjection(v); draw(); const off=snapshotPNG(true); await new Promise(res=>off.toBlob(b=>{ const url=URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; a.download=`view_${v}.png`; a.click(); URL.revokeObjectURL(url); res(); },'image/png')); } setProjection(orig); draw(); };

/* DXF */
function DXF(){ this.e=[]; this.push=s=>this.e.push(s+'\n'); this.addHeader=()=>{ this.push('0');this.push('SECTION');this.push('2');this.push('HEADER');this.push('9');this.push('$INSUNITS');this.push('70');this.push('4'); this.push('0');this.push('ENDSEC'); this.push('0');this.push('SECTION');this.push('2');this.push('TABLES'); this.push('0');this.push('TABLE');this.push('2');this.push('LAYER');this.push('70');this.push('12'); ['0','BUS','ELBOW','CAB','DIM','ANNO','JOINT','MOUNT','ENDCAP'].forEach((n,i)=>{ this.push('0');this.push('LAYER');this.push('2');this.push(n);this.push('70');this.push('0');this.push('62');this.push((i+1));this.push('6');this.push('CONTINUOUS'); }); this.push('0');this.push('ENDTAB'); this.push('0');this.push('ENDSEC'); this.push('0');this.push('SECTION');this.push('2');this.push('ENTITIES'); }; this.addLine=(x1,y1,x2,y2,layer='0')=>{ this.push('0');this.push('LINE'); this.push('8');this.push(layer); this.push('10');this.push(x1); this.push('20');this.push(-y1); this.push('30');this.push(0); this.push('11');this.push(x2); this.push('21');this.push(-y2); this.push('31');this.push(0); }; this.addText=(x,y,h,txt,layer='0')=>{ this.push('0');this.push('TEXT'); this.push('8');this.push(layer); this.push('10');this.push(x); this.push('20');this.push(-y); this.push('30');this.push(0); this.push('40');this.push(h); this.push('1');this.push(txt); }; this.end=()=>{ this.push('0');this.push('ENDSEC'); this.push('0');this.push('EOF'); return this.e.join(''); }; }
function p2(x,y,z){ const r=proj(x,y,z); return {x:r[0],y:r[1]}; }
function addBoxLines(out,x,y,z,w,d,h){ const v=[[x,y,z],[x+w,y,z],[x+w,y+d,z],[x,y+d,z],[x,y,z+h],[x+w,y,z+h],[x+w,y+d,z+h],[x,y+d,z+h]].map(t=>p2(...t)); const s=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]; s.forEach(([a,b])=>out.push([v[a],v[b]])); }
$('saveDXF').onclick=()=>{ const dxf=new DXF(); dxf.addHeader(); const add=(pairs,layer)=>pairs.forEach(([A,B])=>dxf.addLine(A.x,A.y,B.x,B.y,layer)); const p=P(), bw=p.busW, bh=p.busH;
  { const top=originTop()[2], base=top-p.startH; const arr=[]; addBoxLines(arr,0,0,base,p.startW,p.startD,p.startH); add(arr,'CAB'); }
  let pos=originTop();
  for(let i=0;i<state.segs.length;i++){
    const cur=state.segs[i], L=cur.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const sc=prev?elbowCuts(prev.dir,cur.dir).b:0, ec=next?elbowCuts(cur.dir,next.dir).a:0;
    const start=adv(pos,cur.dir,sc), Ldraw=Math.max(0,L-sc-ec), a=axis(cur.dir), s=[];
    if(Ldraw>0){
      if(a==='Z'){ addBoxLines(s,start[0]-bw/2,start[1]-bw/2,sgn(cur.dir)>0?start[2]:start[2]-Ldraw,bw,bw,Ldraw); }
      if(a==='X'){ addBoxLines(s,sgn(cur.dir)>0?start[0]:start[0]-Ldraw,start[1]-bw/2,start[2]-bh/2,Ldraw,bw,bh); }
      if(a==='Y'){ addBoxLines(s,start[0]-bw/2,sgn(cur.dir)>0?start[1]:start[1]-Ldraw,start[2]-bh/2,bw,Ldraw,bh); }
      add(s,'BUS');
      const m=state.module|0, full=Math.floor((cur.len|0)/m);
      for(let k=1;k<=full;k++){
        const d=k*m - sc; if(d<=0||d>=Ldraw) continue; const C=adv(start,cur.dir,d), arr=[];
        if(a==='Z') addBoxLines(arr, C[0]-bw/2,C[1]-bw/2,C[2]-JOINT_LEN/2,bw,bw,JOINT_LEN);
        if(a==='X') addBoxLines(arr, C[0]-JOINT_LEN/2,C[1]-bw/2,C[2]-BUS_H/2,JOINT_LEN,bw,BUS_H);
        if(a==='Y') addBoxLines(arr, C[0]-bw/2,C[1]-JOINT_LEN/2,C[2]-BUS_H/2,bw,JOINT_LEN,BUS_H);
        add(arr,'JOINT');
      }
      const mounts=mountPositionsForSegment(start,cur,Ldraw,sc,ec,prev,next,+$('mountStep').value||1000);
      for(const d of mounts){
        const C=adv(start,cur.dir,d), arr=[];
        if(a==='X') addBoxLines(arr,C[0]-MOUNT_ALONG/2,C[1]-bw/2,C[2]-BUS_H/2-MOUNT_THICK,MOUNT_ALONG,bw,MOUNT_THICK);
        if(a==='Y') addBoxLines(arr,C[0]-bw/2,C[1]-MOUNT_ALONG/2,C[2]-BUS_H/2-MOUNT_THICK,bw,MOUNT_ALONG,MOUNT_THICK);
        add(arr,'MOUNT');
      }
    }
    if(next && (sc||ec)){
      const vertex=adv(pos,cur.dir,L); const U=dirVec(cur.dir), V=dirVec(next.dir), N=cross(U,V);
      const vertical=(axis(cur.dir)==='Z'||axis(next.dir)==='Z'); const thick=vertical?bw:bh; const half=vertical?(bh/2):(bw/2);
      const poly=LpolyCornerSolid(ec,ec,half); const t2=thick/2;
      const up=poly.map(p=>madd(vertex,U,p[0],V,p[1],N,+t2)); const dn=poly.map(p=>madd(vertex,U,p[0],V,p[1],N,-t2));
      for(let i2=0;i2<up.length;i2++){ const j=(i2+1)%up.length; const A=p2(...up[i2]), B=p2(...up[j]), Cc=p2(...dn[i2]); dxf.addLine(A.x,A.y,B.x,B.y,'ELBOW'); dxf.addLine(A.x,A.y,Cc.x,Cc.y,'ELBOW'); }
      for(let i2=0;i2<dn.length;i2++){ const j=(i2+1)%dn.length; const A=p2(...dn[i2]), B=p2(...dn[j]); dxf.addLine(A.x,A.y,B.x,B.y,'ELBOW'); }
    }
    pos=adv(pos,cur.dir,L);
  }
  if($('endType').value==='NKU'){ const e=endPoint(), top=e[2], base=top-P().endH; const arr=[]; addBoxLines(arr,e[0]-P().endW/2,e[1]-P().endD/2,base,P().endW,P().endD,P().endH); add(arr,'CAB'); }
  if($('endType').value==='ENDCAP'){ const e=endPoint(), a=axis((state.segs[state.segs.length-1]||{dir:'+Z'}).dir), arr=[]; const bw=P().busW;
    if(a==='Z') addBoxLines(arr,e[0]-bw/2,e[1]-bw/2,e[2]-JOINT_LEN/2,bw,bw,JOINT_LEN);
    if(a==='X') addBoxLines(arr,e[0]-JOINT_LEN/2,e[1]-bw/2,e[2]-BUS_H/2,JOINT_LEN,bw,BUS_H);
    if(a==='Y') addBoxLines(arr,e[0]-bw/2,e[1]-JOINT_LEN/2,e[2]-BUS_H/2,bw,JOINT_LEN,BUS_H);
    add(arr,'ENDCAP');
  }
  computeDimBadges().forEach(b=>dxf.addText(b.x/DPR,b.y/DPR,20,b.text,'DIM'));
  state.annos.forEach(a=>{ const pv=a.pos[viewMode]||a.pos.ISO||newPos(); const A=localToScreen(pv.ax,pv.ay), B=localToScreen(pv.bx,pv.by); dxf.addLine(A.x/DPR,A.y/DPR,(B.x+80)/DPR,(B.y+12)/DPR,'ANNO'); dxf.addText(B.x/DPR,(B.y+12)/DPR,20,a.text,'ANNO'); });
  const blob=new Blob([dxf.end()],{type:'application/dxf'}), url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`busway_${viewMode}.dxf`; a.click(); URL.revokeObjectURL(url);
};

/* XLS */
$('saveXLS').onclick=()=>{ const sp=state.calc?computeSpec():null; const cost=sp?computeCost(sp):null;
  const xl=[]; xl.push(`<?xml version="1.0"?>`); xl.push(`<?mso-application progid="Excel.Sheet"?>`);
  xl.push(`<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">`);
  xl.push(`<Styles><Style ss:ID="h"><Font ss:Bold="1"/><Interior ss:Color="#EEEEEE" ss:Pattern="Solid"/></Style></Styles>`);
  xl.push(`<Worksheet ss:Name="Спецификация"><Table>`);
  function row(a,b,head=false){ xl.push(`<Row><Cell${head?' ss:StyleID="h"':''}><Data ss:Type="String">${a}</Data></Cell><Cell><Data ss:Type="String">${b}</Data></Cell></Row>`); }
  row('Чертёж шинопровода','');
  if(sp){
    row('Материал/номинал/IP', `${$('mat').value==='CU'?'Cu':'Al'} / ${$('rating').value} A / ${$('ip').value}`);
    row('Модуль (мм)', sp.module); row('Итого длина (мм)', sp.totalLen);
    row('Горизонтальные (мм)', sp.lenHoriz); row('Вертикально вверх (мм)', sp.lenUp); row('Вертикально вниз (мм)', sp.lenDown);
    row('Блок к НКУ, шт', sp.nkuBlocks); row('Блок к ТР, шт', sp.trBlocks); row('Заглушка', sp.endCap?'есть':'—');
    row('Соединители всего, шт', sp.joints.total); row('— модульные', sp.joints.mod); row('— на углах (×2)', sp.joints.corners); row('— у НКУ (×1)', sp.joints.nku); row('— у ТР (×1)', sp.joints.tr);
    row('Повороты вертикальные', sp.vert); row('Повороты горизонтальные', sp.horiz); row('Крепления, шт', computeSpec().mounts);
    xl.push(`<Row/>`); row('Смета','',true);
    if(cost){
      row('Прямая секция (м)', `${(sp.totalLen/1000).toFixed(2)} м × ${fmtNum(cost.prices.straight)} = ${fmtNum(cost.breakdown.straight)}`);
      row('Углы (шт)', `${sp.vert+sp.horiz} × ${fmtNum(cost.prices.elbow)} = ${fmtNum(cost.breakdown.elbow)}`);
      row('Соединители (шт)', `${sp.joints.total} × ${fmtNum(cost.prices.joint)} = ${fmtNum(cost.breakdown.joint)}`);
      row('Заглушка (шт)', `${sp.endCap} × ${fmtNum(cost.prices.endcap||0)} = ${fmtNum(cost.breakdown.endcap||0)}`);
      row('Фланцевый блок (шт)', `${sp.nkuBlocks} × ${fmtNum(cost.prices.feeder||0)} = ${fmtNum(cost.breakdown.feeder||0)}`);
      row('Секция к ТР (шт)', `${sp.trBlocks} × ${fmtNum(cost.prices.transformer||0)} = ${fmtNum(cost.breakdown.transformer||0)}`);
      row('Крепёж (шт)', `${sp.mounts} × ${fmtNum(cost.prices.mount||0)} = ${fmtNum(cost.breakdown.mount||0)}`);
      row('ИТОГО', fmtNum(cost.total), true);
    }
    xl.push(`<Row/>`); xl.push(`<Row><Cell ss:StyleID="h"><Data ss:Type="String">Длина, мм</Data></Cell><Cell ss:StyleID="h"><Data ss:Type="String">Кол-во, шт</Data></Cell></Row>`);
    [...sp.parts.entries()].sort((a,b)=>b[0]-a[0]).forEach(([len,cnt])=>row(String(len),String(cnt)));
  } else row('Подсказка','Нажмите «Рассчитать разбиение», затем выгрузите XLS повторно.');
  xl.push(`</Table></Worksheet></Workbook>`);
  const blob=new Blob([xl.join('')],{type:'application/vnd.ms-excel'}), url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='busway_spec.xls'; a.click(); URL.revokeObjectURL(url);
};

/* PDF (упрощённо — добавлена смета) */
$('savePDF').onclick=async ()=>{
  const views=['ISO','TOP','FRONT','BACK','LEFT','RIGHT'], orig=viewMode, shots=[];
  for(const v of views){ setProjection(v); draw(); const off=snapshotPNG(true); shots.push({v, data:off.toDataURL('image/png')}); }
  setProjection(orig); draw();
  const sp=state.calc?computeSpec():null, p=P(); const startTitle=(p.startType==='NKU'?'ГРЩ':'Трансформатор'), endTitle=($('endType').value==='NKU'?'ГРЩ':'Заглушка');
  const cost=sp?computeCost(sp):null;
  const names={ISO:'Изометрия',TOP:'Вид сверху',FRONT:'Вид спереди',BACK:'Вид сзади',LEFT:'Вид слева',RIGHT:'Вид справа'};
  const H=`<!doctype html><html><head><meta charset="utf-8"><title>Проект шинопровода</title>
    <style>@page{size:A4;margin:12mm}body{margin:0;background:#fff;color:#000;font:12px/1.35 Segoe UI,Arial}
    .page{width:210mm;min-height:297mm;padding:10mm 12mm;box-sizing:border-box;page-break-after:always;position:relative}
    .frame{position:absolute;left:6mm;right:6mm;top:6mm;bottom:6mm;border:1px solid #000}
    h1{font-size:18px;margin:0 0 6mm}h2{font-size:15px;margin:0 0 4mm}.img{width:100%;border:1px solid #ccc}
    table{border-collapse:collapse;width:100%}td,th{border:1px solid #999;padding:4px 6px;text-align:left}
    .pair{display:grid;grid-template-columns:1fr 1fr;gap:6mm}.small{color:#333}</style></head><body>`;
  let B=`<div class="page"><div class="frame"></div><h1>Чертёж шинопровода</h1>
    <div>Материал: <b>${$('mat').value==='CU'?'Медь (Cu)':'Алюминий (Al)'}</b>, Номинал: <b>${$('rating').value} А</b>, IP: <b>${$('ip').value}</b></div>
    <div>Начало: <b>${startTitle}</b> (W=${p.startW} D=${p.startD} H=${p.startH}); Конец: <b>${endTitle}</b>${$('endType').value==='NKU'?` (W=${p.endW} D=${p.endD} H=${p.endH})`:''}</div>
    ${sp?`<div class="pair"><div><h2>Сводка</h2><table>
      <tr><td>Итого длина</td><td>${sp.totalLen} мм</td></tr>
      <tr><td>Горизонтальные</td><td>${sp.lenHoriz} мм</td></tr>
      <tr><td>Вертикально вверх</td><td>${sp.lenUp} мм</td></tr>
      <tr><td>Вертикально вниз</td><td>${sp.lenDown} мм</td></tr>
      <tr><td>Повороты: вертик.</td><td>${sp.vert}</td></tr>
      <tr><td>Повороты: гориз.</td><td>${sp.horiz}</td></tr>
      <tr><td>Крепления</td><td>${computeSpec().mounts}</td></tr>
      <tr><td>Соединители всего</td><td>${sp.joints.total}</td></tr></table></div>
      <div><h2>Изометрия</h2><img class="img" src="${shots.find(s=>s.v==='ISO').data}"></div></div>`:`<div class="small"><i>Нажмите «Рассчитать разбиение» для спецификации.</i></div>`}
    </div>`;
  if(sp && cost){
    const rows=[
      ['Прямая секция (м)', `${(sp.totalLen/1000).toFixed(2)} × ${fmtNum(cost.prices.straight)} = ${fmtNum(cost.breakdown.straight)}`],
      ['Углы (шт)', `${sp.vert+sp.horiz} × ${fmtNum(cost.prices.elbow)} = ${fmtNum(cost.breakdown.elbow)}`],
      ['Соединительные блоки (шт)', `${sp.joints.total} × ${fmtNum(cost.prices.joint)} = ${fmtNum(cost.breakdown.joint)}`],
      ['Заглушка (шт)', `${sp.endCap} × ${fmtNum(cost.prices.endcap||0)} = ${fmtNum(cost.breakdown.endcap||0)}`],
      ['Фланцевый блок (шт)', `${sp.nkuBlocks} × ${fmtNum(cost.prices.feeder||0)} = ${fmtNum(cost.breakdown.feeder||0)}`],
      ['Секция к трансформатору (шт)', `${sp.trBlocks} × ${fmtNum(cost.prices.transformer||0)} = ${fmtNum(cost.breakdown.transformer||0)}`],
      ['Крепёж (шт)', `${sp.mounts} × ${fmtNum(cost.prices.mount||0)} = ${fmtNum(cost.breakdown.mount||0)}`],
      ['ИТОГО', fmtNum(cost.total)]
    ].map(r=>`<tr><td>${r[0]}</td><td>${r[1]}</td></tr>`).join('');
    B+=`<div class="page"><div class="frame"></div><h2>Смета</h2><table>${rows}</table></div>`;
  }
  shots.forEach(s=>{ B+=`<div class="page"><div class="frame"></div><h2>${names[s.v]||s.v}</h2><img class="img" src="${s.data}"></div>`; });
  const blob=new Blob([H+B+'</body></html>'],{type:'text/html'}), url=URL.createObjectURL(blob); window.open(url,'_blank');
};

/* ========= СПЕЦИФИКАЦИЯ ========= */
function computeSpec(){
  const m=state.module|0, map=new Map(); let total=0, jointsMod=0, corners=0, vert=0, horiz=0, mounts=0;
  let lenH=0,lenUp=0,lenDown=0; let pos=originTop(); const target=+$('mountStep').value||1000;
  for(let i=0;i<state.segs.length;i++){
    const s=state.segs[i], L=s.len|0, prev=state.segs[i-1], next=state.segs[i+1];
    const sc=prev?elbowCuts(prev.dir,s.dir).b:0, ec=next?elbowCuts(s.dir,next.dir).a:0; const Ldraw=Math.max(0,L-sc-ec);
    total+=L; if(axis(s.dir)==='Z'){ if(sgn(s.dir)>0) lenUp+=L; else lenDown+=L; } else lenH+=L;
    if(m>0){ const full=Math.floor(L/m), rem=L%m; if(full>0) map.set(m,(map.get(m)||0)+full); if(rem>0) map.set(rem,(map.get(rem)||0)+1); const parts=full+(rem>0?1:0); jointsMod+=Math.max(0,parts-1); }
    if(axis(s.dir)!=='Z') mounts+=mountPositionsForSegment(adv(pos,s.dir,sc),s,Ldraw,sc,ec,prev,next,target).length;
    if(next && axis(s.dir)!==axis(next.dir)){ corners++; if(axis(s.dir)==='Z'||axis(next.dir)==='Z') vert++; else horiz++; }
    pos=adv(pos,s.dir,L);
  }
  const nku=( $('startType').value==='NKU'?1:0 ) + ( $('endType').value==='NKU'?1:0 );
  const tr =( $('startType').value==='TR'?1:0 );
  const endcap=($('endType').value==='ENDCAP'?1:0);
  return {module:m,totalLen:total,parts:map,joints:{total:jointsMod+corners*2+nku+tr,mod:jointsMod,corners:corners*2,nku,tr},vert,horiz,nkuBlocks:nku,trBlocks:tr,endCap:endcap,mounts,mountStep:target,lenHoriz:lenH,lenUp,lenDown};
}
function renderSpec(){
  if(!state.calc){ $('spec').style.display='none'; return; }
  const sp=computeSpec(); $('spec').style.display='block';
  $('spHeader').textContent=`${$('mat').value==='CU'?'Cu':'Al'} / ${$('rating').value} A / ${$('ip').value}`;
  $('spModule').textContent=sp.module+' мм'; $('spTotalLen').textContent=sp.totalLen+' мм';
  $('spLenHoriz').textContent=sp.lenHoriz+' мм'; $('spLenUp').textContent=sp.lenUp+' мм'; $('spLenDown').textContent=sp.lenDown+' мм';
  $('spNkuBlocks').textContent=sp.nkuBlocks; $('spTrBlocks').textContent=sp.trBlocks; $('spEndCap').textContent=sp.endCap?'1':'—';
  $('spJointsTotal').textContent=sp.joints.total; $('spJointsMod').textContent=sp.joints.mod; $('spJointsCorners').textContent=sp.joints.corners; $('spJointsNku').textContent=sp.joints.nku; $('spJointsTr').textContent=sp.joints.tr;
  $('spVert').textContent=sp.vert; $('spHoriz').textContent=sp.horiz; $('spMounts').textContent=($('mountOn').value==='1')?`${sp.mounts} шт (шаг ~${sp.mountStep} мм)`:'—';
  const tbody=$('spTable').querySelector('tbody'); tbody.innerHTML=''; [...sp.parts.entries()].sort((a,b)=>b[0]-a[0]).forEach(([len,cnt])=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${len}</td><td>${cnt}</td>`; tbody.appendChild(tr); });

  const cost=computeCost(sp);
  $('costStraight').textContent = money0(cost.breakdown.straight) + ` (${(sp.totalLen/1000).toFixed(2)} м × ${fmtNum(cost.prices.straight)})`;
  $('costElbows').textContent   = money0(cost.breakdown.elbow) + ` (${sp.vert+sp.horiz} × ${fmtNum(cost.prices.elbow)})`;
  $('costJoints').textContent   = money0(cost.breakdown.joint) + ` (${sp.joints.total} × ${fmtNum(cost.prices.joint)})`;
  $('costEndcap').textContent   = money0(cost.breakdown.endcap||0) + ` (${sp.endCap} × ${fmtNum(cost.prices.endcap||0)})`;
  $('costFeeder').textContent   = money0(cost.breakdown.feeder||0) + ` (${sp.nkuBlocks} × ${fmtNum(cost.prices.feeder||0)})`;
  $('costTransformer').textContent= money0(cost.breakdown.transformer||0) + ` (${sp.trBlocks} × ${fmtNum(cost.prices.transformer||0)})`;
  $('costMounts').textContent   = money0(cost.breakdown.mount||0) + ` (${sp.mounts} × ${fmtNum(cost.prices.mount||0)})`;
  $('costTotal').textContent    = money0(cost.total);
}
$('saveCSV').onclick=()=>{ if(!state.calc) return; const sp=computeSpec(); const cost=computeCost(sp);
  const rows=[['Материал',$('mat').value==='CU'?'Cu':'Al'],['Номинал, A',$('rating').value],['IP',$('ip').value],
  ['Модуль (мм)',sp.module],['Итого длина (мм)',sp.totalLen],['Горизонтальные (мм)',sp.lenHoriz],['Вертикально вверх (мм)',sp.lenUp],['Вертикально вниз (мм)',sp.lenDown],['Блок к НКУ, шт',sp.nkuBlocks],['Блок к ТР, шт',sp.trBlocks],['Заглушка',sp.endCap?'1':'0'],['Соединители всего, шт',sp.joints.total],['— модульные, шт',sp.joints.mod],['— на углах (×2), шт',sp.joints.corners],['— у НКУ (×1), шт',sp.joints.nku],['— у ТР (×1), шт',sp.joints.tr],['Повороты вертикальные, шт',sp.vert],['Повороты горизонтальные, шт',sp.horiz],['Крепления, шт',sp.mounts],['Шаг крепления, мм',sp.mountStep],[],['Смета','руб без НДС'],['Прямая секция (м)', (sp.totalLen/1000).toFixed(2)+' × '+cost.prices.straight+' = '+cost.breakdown.straight],['Углы (шт)', (sp.vert+sp.horiz)+' × '+cost.prices.elbow+' = '+cost.breakdown.elbow],['Соединители (шт)', sp.joints.total+' × '+cost.prices.joint+' = '+cost.breakdown.joint],['Заглушка (шт)', sp.endCap+' × '+(cost.prices.endcap||0)+' = '+(cost.breakdown.endcap||0)],['Фланцевый блок (шт)', sp.nkuBlocks+' × '+(cost.prices.feeder||0)+' = '+(cost.breakdown.feeder||0)],['Секция к ТР (шт)', sp.trBlocks+' × '+(cost.prices.transformer||0)+' = '+(cost.breakdown.transformer||0)],['Крепёж (шт)', sp.mounts+' × '+(cost.prices.mount||0)+' = '+(cost.breakdown.mount||0)],['ИТОГО', cost.total]];
  const csv=rows.map(r=>r.join(';')).join('\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='spec.csv'; a.click(); URL.revokeObjectURL(url);
};

/* ========= УПРАВЛЕНИЕ ========= */
function fillRatings(){ const sel=$('rating'); sel.innerHTML=''; const list=$('mat').value==='CU'?R_CU:R_AL; list.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); }); sel.value=list[0]; draw(); if(state.calc) renderSpec(); }
$('mat').addEventListener('change', fillRatings);
$('rating').addEventListener('change',()=>{ draw(); if(state.calc) renderSpec(); });
$('startType').addEventListener('change',()=>{ const v=$('startType').value;
  if(v==='NKU'){ $('startW').value=600; $('startD').value=600; $('startH').value=2200; }
  else { $('startW').value=2000; $('startD').value=1400; $('startH').value=1700; }
  draw(); if(state.calc) renderSpec();
});
$('endType').addEventListener('change',()=>{ const v=$('endType').value; $('endDims').classList.toggle('hid',v!=='NKU'); draw(); if(state.calc) renderSpec(); });
['startW','startD','startH','endW','endD','endH','ip','mountOn','mountStep','moduleLen'].forEach(id=>{
  $(id).addEventListener('input',()=>{ draw(); if(state.calc) renderSpec(); });
});
$('calc').onclick=()=>{ const m=+$('moduleLen').value||0; if(!(m>0)){ msg.textContent='Укажите длину модуля (>0)'; setTimeout(()=>msg.textContent='',1500); return; } state.module=m; state.calc=true; giz.style.display='none'; tag.style.display='none'; pop.style.display='none'; draw(); renderSpec(); };
$('uncalc').onclick=()=>{ state.calc=false; draw(); renderSpec(); };
$('undo').onclick=()=>{ state.segs.pop(); draw(); if(state.calc) renderSpec(); };
$('clear').onclick=()=>{ state.segs.length=0; state.calc=false; draw(); renderSpec(); };

/* проект: сохранить/загрузить */
$('saveProj').onclick=()=>{ const data={version:7,view:viewMode,params:{mat:$('mat').value,rating:+$('rating').value,ip:$('ip').value,startType:$('startType').value,startW:+$('startW').value,startD:+$('startD').value,startH:+$('startH').value,endType:$('endType').value,endW:+$('endW').value,endD:+$('endD').value,endH:+$('endH').value,moduleLen:+$('moduleLen').value,mountOn:$('mountOn').value,mountStep:+$('mountStep').value},segs:state.segs,calc:state.calc,dimOffsets:state.dimOffsets,annos:state.annos}; const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='busway_project.json'; a.click(); URL.revokeObjectURL(url); };
$('loadProj').onclick=()=>$('loadInput').click();
$('loadInput').addEventListener('change',e=>{
  const f=e.target.files[0]; if(!f) return; const rd=new FileReader();
  rd.onload=()=>{ try{ const data=JSON.parse(rd.result);
    $('mat').value=data.params.mat||'AL'; fillRatings(); $('rating').value=data.params.rating||R_AL[0]; $('ip').value=data.params.ip||'IP55';
    $('startType').value=data.params.startType||'NKU'; $('startW').value=data.params.startW||600; $('startD').value=data.params.startD||600; $('startH').value=data.params.startH||2200;
    $('endType').value=data.params.endType||'ENDCAP'; $('endW').value=data.params.endW||600; $('endD').value=data.params.endD||600; $('endH').value=data.params.endH||2200;
    $('moduleLen').value=data.params.moduleLen||3000; $('mountOn').value=data.params.mountOn||'1'; $('mountStep').value=data.params.mountStep||1000;
    $('endDims').classList.toggle('hid',$('endType').value!=='NKU');
    state.segs=Array.isArray(data.segs)?data.segs:[]; state.calc=!!data.calc; state.dimOffsets=data.dimOffsets||{ISO:{},TOP:{},FRONT:{},BACK:{},LEFT:{},RIGHT:{}}; state.annos=Array.isArray(data.annos)?data.annos:[]; state.movingAnno={id:null,what:null,view:null}; setProjection(data.view||'ISO'); draw(); if(state.calc) renderSpec();
  }catch(err){ alert('Ошибка загрузки: '+err.message); } }; rd.readAsText(f,'utf-8');
});
$('btnFS').onclick=()=>{ const el=wrap, req=el.requestFullscreen||el.webkitRequestFullscreen||el.mozRequestFullScreen||el.msRequestFullscreen; const exit=document.exitFullscreen||document.webkitExitFullscreen||document.mozCancelFullScreen||document.msExitFullscreen; if(!(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement)){ req&&req.call(el); } else { exit&&exit.call(document); } setTimeout(()=>{ resize(); fit(); },120); };

/* ========= ЦЕНЫ ========= */
/* исходный текст прайса (заводской) — вставлен как прислал */
const PRICE_TEXT_DEFAULT = `
BDW4504GM55 Прямая секция магистральная, AL, 400А, 3L+N+PE, IP55 60 420,00
BDW4505GM55 Прямая секция магистральная, AL, 500А, 3L+N+PE, IP55 60 420,00
BDW4506GM55 Прямая секция магистральная, AL, 630А, 3L+N+PE, IP55 60 420,00
BDW4508GM55 Прямая секция магистральная, AL, 800А, 3L+N+PE, IP55 60 420,00
BDW4510GM55 Прямая секция магистральная, AL, 1000А, 3L+N+PE, IP55 69 600,00
BDW4512GM55 Прямая секция магистральная, AL, 1250А, 3L+N+PE, IP55 87 120,00
BDW4516GM55 Прямая секция магистральная, AL, 1600А, 3L+N+PE, IP55 111 180,00
BDW4520GM55 Прямая секция магистральная, AL, 2000А, 3L+N+PE, IP55 138 600,00
BDW4525GM55 Прямая секция магистральная, AL, 2500А, 3L+N+PE, IP55 176 400,00
BDW4532GM55 Прямая секция магистральная, AL, 3200А, 3L+N+PE, IP55 226 200,00
BDW4540GM55 Прямая секция магистральная, AL, 4000А, 3L+N+PE, IP55 282 600,00
BDW4550GM55 Прямая секция магистральная, AL, 5000А, 3L+N+PE, IP55 353 400,00
BDW4504GELM55 Угловая секция, AL, 400А, 3L+N+PE, IP55 13 980,00
BDW4505GELM55 Угловая секция, AL, 500А, 3L+N+PE, IP55 13 980,00
BDW4506GELM55 Угловая секция, AL, 630А, 3L+N+PE, IP55 13 980,00
BDW4508GELM55 Угловая секция, AL, 800А, 3L+N+PE, IP55 13 980,00
BDW4510GELM55 Угловая секция, AL, 1000А, 3L+N+PE, IP55 17 280,00
BDW4512GELM55 Угловая секция, AL, 1250А, 3L+N+PE, IP55 19 740,00
BDW4516GELM55 Угловая секция, AL, 1600А, 3L+N+PE, IP55 27 120,00
BDW4520GELM55 Угловая секция, AL, 2000А, 3L+N+PE, IP55 31 200,00
BDW4525GELM55 Угловая секция, AL, 2500А, 3L+N+PE, IP55 34 500,00
BDW4532GELM55 Угловая секция, AL, 3200А, 3L+N+PE, IP55 41 100,00
BDW4540GELM55 Угловая секция, AL, 4000А, 3L+N+PE, IP55 44 400,00
BDW4550GELM55 Угловая секция, AL, 5000А, 3L+N+PE, IP55 47 760,00
BDW4504GJPKM55 Соединительный блок, AL, 400А, 3L+N+PE, IP55 25 920,00
BDW4505GJPKM55 Соединительный блок, AL, 500А, 3L+N+PE, IP55 25 920,00
BDW4506GJPKM55 Соединительный блок, AL, 630А, 3L+N+PE, IP55 25 920,00
BDW4508GJPKM55 Соединительный блок, AL, 800А, 3L+N+PE, IP55 25 920,00
BDW4510GJPKM55 Соединительный блок, AL, 1000А, 3L+N+PE, IP55 30 120,00
BDW4512GJPKM55 Соединительный блок, AL, 1250А, 3L+N+PE, IP55 34 800,00
BDW4516GJPKM55 Соединительный блок, AL, 1600А, 3L+N+PE, IP55 41 700,00
BDW4520GJPKM55 Соединительный блок, AL, 2000А, 3L+N+PE, IP55 53 220,00
BDW4525GJPKM55 Соединительный блок, AL, 2500А, 3L+N+PE, IP55 73 140,00
BDW4532GJPKM55 Соединительный блок, AL, 3200А, 3L+N+PE, IP55 88 380,00
BDW4540GJPKM55 Соединительный блок, AL, 4000А, 3L+N+PE, IP55 119 460,00
BDW4550GJPKM55 Соединительный блок, AL, 5000А, 3L+N+PE, IP55 140 400,00
BDW501ECM55 Концевая заглушка, AL, 400А, IP55 8 460,00
BDW502ECM55 Концевая заглушка, AL, 1000А, IP55 8 700,00
BDW503ECM55 Концевая заглушка, AL, 1250А, IP55 9 540,00
BDW504ECM55 Концевая заглушка, AL, 1600А, IP55 10 080,00
BDW505ECM55 Концевая заглушка, AL, 2000А, IP55 10 620,00
BDW506ECM55 Концевая заглушка, AL, 2500А, IP55 11 760,00
BDW507ECM55 Концевая заглушка, AL, 3200А, IP55 12 480,00
BDW508ECM55 Концевая заглушка, AL, 4000А, IP55 13 680,00
BDW509ECM55 Концевая заглушка, AL, 5000А, IP55 15 060,00
BDW4504GFEM55 Фланцевый блок подачи питания, AL, 400А, 3L+N+PE, IP55 27 120,00
BDW4505GFEM55 Фланцевый блок подачи питания, AL, 500А, 3L+N+PE, IP55 27 120,00
BDW4506GFEM55 Фланцевый блок подачи питания, AL, 630А, 3L+N+PE, IP55 27 120,00
BDW4508GFEM55 Фланцевый блок подачи питания, AL, 800А, 3L+N+PE, IP55 27 120,00
BDW4510GFEM55 Фланцевый блок подачи питания, AL, 1000А, 3L+N+PE, IP55 35 340,00
BDW4512GFEM55 Фланцевый блок подачи питания, AL, 1250А, 3L+N+PE, IP55 41 100,00
BDW4516GFEM55 Фланцевый блок подачи питания, AL, 1600А, 3L+N+PE, IP55 39 840,00
BDW4520GFEM55 Фланцевый блок подачи питания, AL, 2000А, 3L+N+PE, IP55 69 060,00
BDW4525GFEM55 Фланцевый блок подачи питания, AL, 2500А, 3L+N+PE, IP55 87 120,00
BDW4532GFEM55 Фланцевый блок подачи питания, AL, 3200А, 3L+N+PE, IP55 97 020,00
BDW4540GFEM55 Фланцевый блок подачи питания, AL, 4000А, 3L+N+PE, IP55 111 840,00
BDW4550GFEM55 Фланцевый блок подачи питания, AL, 5000А, 3L+N+PE, IP55 130 200,00
BDW4504GFETM55 Секция подключения к трансформатору, AL, 400А, 3L+N+PE, IP55 457 200,00
BDW4505GFETM55 Секция подключения к трансформатору, AL, 500А, 3L+N+PE, IP55 457 200,00
BDW4506GFETM55 Секция подключения к трансформатору, AL, 630А, 3L+N+PE, IP55 457 200,00
BDW4508GFETM55 Секция подключения к трансформатору, AL, 800А, 3L+N+PE, IP55 457 200,00
BDW4510GFETM55 Секция подключения к трансформатору, AL, 1000А, 3L+N+PE, IP55 531 600,00
BDW4512GFETM55 Секция подключения к трансформатору, AL, 1250А, 3L+N+PE, IP55 645 000,00
BDW4516GFETM55 Секция подключения к трансформатору, AL, 1600А, 3L+N+PE, IP55 705 600,00
BDW4520GFETM55 Секция подключения к трансформатору, AL, 2000А, 3L+N+PE, IP55 818 400,00
BDW4525GFETM55 Секция подключения к трансформатору, AL, 2500А, 3L+N+PE, IP55 987 600,00
BDW4532GFETM55 Секция подключения к трансформатору, AL, 3200А, 3L+N+PE, IP55 1 625 400,00
BDW4540GFETM55 Секция подключения к трансформатору, AL, 4000А, 3L+N+PE, IP55 1 799 400,00
BDW4550GFETM55 Секция подключения к трансформатору, AL, 5000А, 3L+N+PE, IP55 1 911 000,00
BDW501HE Горизонтальный крепеж на ребро, AL, до 800А 4 200,00
BDW502HE Горизонтальный крепеж на ребро, AL, 1000А 4 356,00
BDW503HE Горизонтальный крепеж на ребро, AL, 1250А 4 530,00
BDW504HE Горизонтальный крепеж на ребро, AL, 1600А 4 818,00
BDW505HE Горизонтальный крепеж на ребро, AL, 2000А 5 166,00
BDW506HE Горизонтальный крепеж на ребро, AL, 2500А 6 420,00
BDW507HE Горизонтальный крепеж на ребро, AL, 3200А 6 960,00
BDW508HE Горизонтальный крепеж на ребро, AL, 4000А 7 860,00
BDW509HE Горизонтальный крепеж на ребро, AL, 5000А 9 420,00
DDW4504GM55 Прямая секция магистральная, CU, 400А, 3L+N+PE, IP55 75 300,00
DDW4505GM55 Прямая секция магистральная, CU, 500А, 3L+N+PE, IP55 85 080,00
DDW4506GM55 Прямая секция магистральная, CU, 630А, 3L+N+PE, IP55 104 580,00
DDW4508GM55 Прямая секция магистральная, CU, 800А, 3L+N+PE, IP55 126 600,00
DDW4510GM55 Прямая секция магистральная, CU, 1000А, 3L+N+PE, IP55 157 800,00
DDW4512GM55 Прямая секция магистральная, CU, 1250А, 3L+N+PE, IP55 196 800,00
DDW4516GM55 Прямая секция магистральная, CU, 1600А, 3L+N+PE, IP55 258 600,00
DDW4520GM55 Прямая секция магистральная, CU, 2000А, 3L+N+PE, IP55 324 000,00
DDW4525GM55 Прямая секция магистральная, CU, 2500А, 3L+N+PE, IP55 402 600,00
DDW4532GM55 Прямая секция магистральная, CU, 3200А, 3L+N+PE, IP55 521 400,00
DDW4540GM55 Прямая секция магистральная, CU, 4000А, 3L+N+PE, IP55 721 200,00
DDW4550GM55 Прямая секция магистральная, CU, 5000А, 3L+N+PE, IP55 901 200,00
DDW4563GM55 Прямая секция магистральная, CU, 6300А, 3L+N+PE, IP55 1 386 000,00
DDW4504GELM55 Угловая секция, CU, 400А, 3L+N+PE, IP55 13 500,00
DDW4505GELM55 Угловая секция, CU, 500А, 3L+N+PE, IP55 14 520,00
DDW4506GELM55 Угловая секция, CU, 630А, 3L+N+PE, IP55 15 600,00
DDW4508GELM55 Угловая секция, CU, 800А, 3L+N+PE, IP55 17 700,00
DDW4510GELM55 Угловая секция, CU, 1000А, 3L+N+PE, IP55 21 840,00
DDW4512GELM55 Угловая секция, CU, 1250А, 3L+N+PE, IP55 24 960,00
DDW4516GELM55 Угловая секция, CU, 1600А, 3L+N+PE, IP55 34 260,00
DDW4520GELM55 Угловая секция, CU, 2000А, 3L+N+PE, IP55 39 420,00
DDW4525GELM55 Угловая секция, CU, 2500А, 3L+N+PE, IP55 43 620,00
DDW4532GELM55 Угловая секция, CU, 3200А, 3L+N+PE, IP55 51 900,00
DDW4540GELM55 Угловая секция, CU, 4000А, 3L+N+PE, IP55 56 100,00
DDW4550GELM55 Угловая секция, CU, 5000А, 3L+N+PE, IP55 60 300,00
DDW4563GELM55 Угловая секция, CU, 6300А, 3L+N+PE, IP55 72 120,00
DDW4504GJPKM55 Соединительный блок, CU, 400А, 3L+N+PE, IP55 31 260,00
DDW4505GJPKM55 Соединительный блок, CU, 500А, 3L+N+PE, IP55 31 260,00
DDW4506GJPKM55 Соединительный блок, CU, 630А, 3L+N+PE, IP55 31 320,00
DDW4508GJPKM55 Соединительный блок, CU, 800А, 3L+N+PE, IP55 34 560,00
DDW4510GJPKM55 Соединительный блок, CU, 1000А, 3L+N+PE, IP55 40 320,00
DDW4512GJPKM55 Соединительный блок, CU, 1250А, 3L+N+PE, IP55 46 620,00
DDW4516GJPKM55 Соединительный блок, CU, 1600А, 3L+N+PE, IP55 60 120,00
DDW4520GJPKM55 Соединительный блок, CU, 2000А, 3L+N+PE, IP55 77 580,00
DDW4525GJPKM55 Соединительный блок, CU, 2500А, 3L+N+PE, IP55 108 180,00
DDW4532GJPKM55 Соединительный блок, CU, 3200А, 3L+N+PE, IP55 131 400,00
DDW4540GJPKM55 Соединительный блок, CU, 4000А, 3L+N+PE, IP55 177 000,00
DDW4550GJPKM55 Соединительный блок, CU, 5000А, 3L+N+PE, IP55 211 200,00
DDW4563GJPKM55 Соединительный блок, CU, 6300А, 3L+N+PE, IP55 306 600,00
DDW501ECM55 Концевая заглушка, CU, 400А, IP55 8 460,00
DDW511ECM55 Концевая заглушка, CU, 500А, IP55 8 460,00
DDW509ECM55 Концевая заглушка, CU, 630А, IP55 8 460,00
DDW510ECM55 Концевая заглушка, CU, 800А, IP55 8 460,00
DDW502ECM55 Концевая заглушка, CU, 1000А, IP55 8 700,00
DDW503ECM55 Концевая заглушка, CU, 1250А, IP55 9 540,00
DDW504ECM55 Концевая заглушка, CU, 1600А, IP55 10 080,00
DDW505ECM55 Концевая заглушка, CU, 2000А, IP55 10 620,00
DDW506ECM55 Концевая заглушка, CU, 2500А, IP55 11 760,00
DDW507ECM55 Концевая заглушка, CU, 3200А, IP55 12 480,00
DDW508ECM55 Концевая заглушка, CU, 4000А, IP55 13 680,00
DDW512ECM55 Концевая заглушка, CU, 5000А, IP55 15 060,00
DDW513ECM55 Концевая заглушка, CU, 6300А, IP55 16 560,00
DDW4504GFEM55 Фланцевый блок подачи питания, CU, 400А, 3L+N+PE, IP55 19 680,00
DDW4505GFEM55 Фланцевый блок подачи питания, CU, 500А, 3L+N+PE, IP55 23 460,00
DDW4506GFEM55 Фланцевый блок подачи питания, CU, 630А, 3L+N+PE, IP55 25 920,00
DDW4508GFEM55 Фланцевый блок подачи питания, CU, 800А, 3L+N+PE, IP55 29 460,00
DDW4510GFEM55 Фланцевый блок подачи питания, CU, 1000А, 3L+N+PE, IP55 38 400,00
DDW4512GFEM55 Фланцевый блок подачи питания, CU, 1250А, 3L+N+PE, IP55 45 180,00
DDW4516GFEM55 Фланцевый блок подачи питания, CU, 1600А, 3L+N+PE, IP55 43 740,00
DDW4520GFEM55 Фланцевый блок подачи питания, CU, 2000А, 3L+N+PE, IP55 75 840,00
DDW4525GFEM55 Фланцевый блок подачи питания, CU, 2500А, 3L+N+PE, IP55 95 700,00
DDW4532GFEM55 Фланцевый блок подачи питания, CU, 3200А, 3L+N+PE, IP55 106 560,00
DDW4540GFEM55 Фланцевый блок подачи питания, CU, 4000А, 3L+N+PE, IP55 123 000,00
DDW4550GFEM55 Фланцевый блок подачи питания, CU, 5000А, 3L+N+PE, IP55 143 400,00
DDW4563GFEM55 Фланцевый блок подачи питания, CU, 6300А, 3L+N+PE, IP55 171 600,00
DDW4504GFETM55 Секция подключения к трансформатору, CU, 400А, 3L+N+PE, IP55 706 800,00
DDW4505GFETM55 Секция подключения к трансформатору, CU, 500А, 3L+N+PE, IP55 706 800,00
DDW4506GFETM55 Секция подключения к трансформатору, CU, 630А, 3L+N+PE, IP55 706 800,00
DDW4508GFETM55 Секция подключения к трансформатору, CU, 800А, 3L+N+PE, IP55 706 800,00
DDW4510GFETM55 Секция подключения к трансформатору, CU, 1000А, 3L+N+PE, IP55 707 400,00
DDW4512GFETM55 Секция подключения к трансформатору, CU, 1250А, 3L+N+PE, IP55 828 000,00
DDW4516GFETM55 Секция подключения к трансформатору, CU, 1600А, 3L+N+PE, IP55 948 600,00
DDW4520GFETM55 Секция подключения к трансформатору, CU, 2000А, 3L+N+PE, IP55 1 069 200,00
DDW4525GFETM55 Секция подключения к трансформатору, CU, 2500А, 3L+N+PE, IP55 1 572 000,00
DDW4532GFETM55 Секция подключения к трансформатору, CU, 3200А, 3L+N+PE, IP55 1 733 400,00
DDW4540GFETM55 Секция подключения к трансформатору, CU, 4000А, 3L+N+PE, IP55 1 897 800,00
DDW4550GFETM55 Секция подключения к трансформатору, CU, 5000А, 3L+N+PE, IP55 2 064 600,00
DDW4563GFETM55 Секция подключения к трансформатору, CU, 6300А, 3L+N+PE, IP55 2 845 200,00
DDW501HE Горизонтальный крепеж на ребро, CU, до 800А 4 002,00
DDW502HE Горизонтальный крепеж на ребро, CU, 1000А 4 002,00
DDW503HE Горизонтальный крепеж на ребро, CU, 1250А 4 314,00
DDW504HE Горизонтальный крепеж на ребро, CU, 1600А 4 590,00
DDW505HE Горизонтальный крепеж на ребро, CU, 2000А 4 920,00
DDW506HE Горизонтальный крепеж на ребро, CU, 2500А 4 920,00
DDW507HE Горизонтальный крепеж на ребро, CU, 3200А 6 660,00
DDW508HE Горизонтальный крепеж на ребро, CU, 4000А 7 500,00
DDW509HE Горизонтальный крепеж на ребро, CU, 5000-6300А 9 000,00
`;

/* структура прайса в памяти */
const priceDB = {
  straight: { AL:{}, CU:{} }, // цена за метр по рейтингу
  elbow:    { AL:{}, CU:{} }, // за шт
  joint:    { AL:{}, CU:{} }, // за шт
  endcap:   { AL:{}, CU:{} }, // за шт
  feeder:   { AL:{}, CU:{} }, // за шт (фланцевый блок)
  transformer:{ AL:{}, CU:{} }, // за шт
  mountRanges:{ AL:[], CU:[] }, // [{min,max,price}]
};

/* парсинг цены: берём ПОСЛЕДНЕЕ большое число, отбрасываем копейки */
function extractPriceInt(line){
  const re=/(\d[\d\s]*)(?:,\d+)?(?!.*\d)/; // последняя числовая группа перед концом
  let m=line.match(/(\d[\d\s]*)(?:,\d+)?/g); // все группы
  if(!m||!m.length) return null;
  let last = m[m.length-1]; // последняя
  last = (last.split(',')[0]||last).replace(/\s+/g,''); // до запятой, убрать пробелы
  const v=parseInt(last,10);
  return isFinite(v)?v:null;
}
function materialFromLine(line){
  if(/\bCU\b|\bCu\b/.test(line)) return 'CU';
  if(/\bAL\b|\bAl\b/.test(line)) return 'AL';
  // по префиксу кода
  if(/^DDW/i.test(line)) return 'CU';
  if(/^BDW/i.test(line)) return 'AL';
  return 'AL';
}
function ratingFromLine(line){
  const m=line.match(/(\d{3,4})\s*А/i); return m?parseInt(m[1],10):null;
}
function pushMountRange(mat, minA, maxA, price){
  priceDB.mountRanges[mat].push({min:minA,max:maxA,price});
}

/* импорт из многострочного текста */
function importPricesFromText(text){
  // очистить
  priceDB.straight.AL={}; priceDB.straight.CU={};
  ['elbow','joint','endcap','feeder','transformer'].forEach(k=>{ priceDB[k].AL={}; priceDB[k].CU={}; });
  priceDB.mountRanges.AL=[]; priceDB.mountRanges.CU=[];
  const lines=(text||'').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  let count=0;
  for(const line of lines){
    const mat=materialFromLine(line);
    const price=extractPriceInt(line);
    if(!price) continue;
    // тип
    if(/Прямая секция магистральная/i.test(line)){
      const r=ratingFromLine(line); if(r) { priceDB.straight[mat][r]=price; count++; }
      continue;
    }
    if(/Угловая секция/i.test(line)){
      const r=ratingFromLine(line); if(r){ priceDB.elbow[mat][r]=price; count++; }
      continue;
    }
    if(/Соединительный блок/i.test(line)){
      const r=ratingFromLine(line); if(r){ priceDB.joint[mat][r]=price; count++; }
      continue;
    }
    if(/Концевая заглушка/i.test(line)){
      const r=ratingFromLine(line); if(r){ priceDB.endcap[mat][r]=price; count++; }
      continue;
    }
    if(/Фланцевый блок подачи питания/i.test(line)){
      const r=ratingFromLine(line); if(r){ priceDB.feeder[mat][r]=price; count++; }
      continue;
    }
    if(/Секция подключения к трансформатору/i.test(line)){
      const r=ratingFromLine(line); if(r){ priceDB.transformer[mat][r]=price; count++; }
      continue;
    }
    if(/Горизонтальный крепеж на ребро/i.test(line)){
      // диапазоны: "до 800А", "5000-6300А", "1000А"
      let min=0,max=99999;
      let m=line.match(/до\s*(\d{2,4})\s*А/i); if(m){ min=0; max=parseInt(m[1],10); pushMountRange(mat,min,max,price); count++; continue; }
      m=line.match(/(\d{3,4})\s*-\s*(\d{3,4})\s*А/i); if(m){ min=parseInt(m[1],10); max=parseInt(m[2],10); pushMountRange(mat,min,max,price); count++; continue; }
      m=line.match(/(\d{3,4})\s*А/i); if(m){ min=max=parseInt(m[1],10); pushMountRange(mat,min,max,price); count++; continue; }
    }
  }
  // сортировка диапазонов для корректного поиска
  priceDB.mountRanges.AL.sort((a,b)=>a.min-b.min);
  priceDB.mountRanges.CU.sort((a,b)=>a.min-b.min);
  return {count, lines:lines.length};
}

/* поиск цены с фоллбэком по рейтингу */
function lookupClosest(map, rating){
  if(map[rating]!=null) return map[rating];
  // ближайший меньший/больший
  const keys=Object.keys(map).map(x=>+x).sort((a,b)=>a-b);
  if(keys.length===0) return 0;
  // возьмём ближайший по абсолютному отклонению
  let bestKey=keys[0], bestDiff=Math.abs(keys[0]-rating);
  for(const k of keys){ const d=Math.abs(k-rating); if(d<bestDiff){ bestDiff=d; bestKey=k; } }
  return map[bestKey]||0;
}
function getMountPrice(mat, rating){
  const arr=priceDB.mountRanges[mat]||[];
  for(const r of arr){ if(rating>=r.min && rating<=r.max) return r.price; }
  // фоллбек: взять ближайший
  let best=null, diff=1e9;
  for(const r of arr){ const d=(rating<r.min)?(r.min-rating):(rating-r.max); if(d<diff){ diff=d; best=r; } }
  return best?best.price:0;
}

/* сохранение/загрузка */
function savePriceDB(){
  const payload={db:priceDB, savedAt:new Date().toISOString()};
  localStorage.setItem(LS_PRICE_KEY, JSON.stringify(payload));
  return payload.savedAt;
}
function loadPriceDB(){
  const raw=localStorage.getItem(LS_PRICE_KEY);
  if(!raw){ importPricesFromText(PRICE_TEXT_DEFAULT); savePriceDB(); return {loaded:false}; }
  try{
    const obj=JSON.parse(raw);
    // мягкая загрузка (структура совместима)
    Object.assign(priceDB.straight.AL, obj.db?.straight?.AL||{});
    Object.assign(priceDB.straight.CU, obj.db?.straight?.CU||{});
    ['elbow','joint','endcap','feeder','transformer'].forEach(k=>{
      Object.assign(priceDB[k].AL, obj.db?.[k]?.AL||{});
      Object.assign(priceDB[k].CU, obj.db?.[k]?.CU||{});
    });
    priceDB.mountRanges.AL = obj.db?.mountRanges?.AL||[];
    priceDB.mountRanges.CU = obj.db?.mountRanges?.CU||[];
    return {loaded:true, savedAt:obj.savedAt};
  }catch(e){
    importPricesFromText(PRICE_TEXT_DEFAULT); savePriceDB(); return {loaded:false};
  }
}

/* расчёт стоимости проекта */
function computeCost(sp){
  const mat=$('mat').value; const rating=+$('rating').value;
  const priceStraight = lookupClosest(priceDB.straight[mat], rating); // per meter
  const priceElbow    = lookupClosest(priceDB.elbow[mat], rating);
  const priceJoint    = lookupClosest(priceDB.joint[mat], rating);
  const priceEndcap   = lookupClosest(priceDB.endcap[mat], rating);
  const priceFeeder   = lookupClosest(priceDB.feeder[mat], rating);
  const priceTransformer=lookupClosest(priceDB.transformer[mat], rating);
  const priceMount    = getMountPrice(mat, rating);

  const meters = sp.totalLen/1000;
  const elbows = sp.vert+sp.horiz;
  const joints = sp.joints.total;
  const mounts = ($('mountOn').value==='1')?sp.mounts:0;

  const sumStraight = Math.round(meters * priceStraight);
  const sumElbow    = elbows * priceElbow;
  const sumJoint    = joints * priceJoint;
  const sumEndcap   = (sp.endCap||0) * priceEndcap;
  const sumFeeder   = (sp.nkuBlocks||0) * priceFeeder;
  const sumTransformer = (sp.trBlocks||0) * priceTransformer;
  const sumMounts   = mounts * priceMount;

  const total = sumStraight+sumElbow+sumJoint+sumEndcap+sumFeeder+sumTransformer+sumMounts;
  return {
    total,
    breakdown:{straight:sumStraight, elbow:sumElbow, joint:sumJoint, endcap:sumEndcap, feeder:sumFeeder, transformer:sumTransformer, mount:sumMounts},
    prices:{straight:priceStraight, elbow:priceElbow, joint:priceJoint, endcap:priceEndcap, feeder:priceFeeder, transformer:priceTransformer, mount:priceMount}
  };
}

/* ========= МОДАЛКА ЦЕН (Alt+P) ========= */
const priceModal=$('priceModal'), pinBlock=$('pinBlock'), priceBlock=$('priceBlock');
function openPrices(){ priceModal.classList.add('show'); $('priceText').value=(localStorage.getItem('_tmp_price_text')||PRICE_TEXT_DEFAULT).trim(); }
function closePrices(){ priceModal.classList.remove('show'); }
document.addEventListener('keydown',e=>{
  if(e.key.toLowerCase()==='p' && e.altKey){ e.preventDefault(); openPrices(); }
  if(e.key==='Escape' && priceModal.classList.contains('show')) closePrices();
});
$('priceClose').onclick=closePrices;
$('pinOk').onclick=()=>{
  const v=$('pinInput').value.trim();
  if(v===ADMIN_PIN){ pinBlock.classList.add('hid'); priceBlock.classList.remove('hid'); const meta=loadPriceDB(); $('priceMeta').textContent = meta.savedAt?('Сохранено: '+new Date(meta.savedAt).toLocaleString()):'Новая база'; updatePriceStats(); }
  else { alert('Неверный PIN'); }
};
$('priceImport').onclick=()=>{
  const text=$('priceText').value; const r=importPricesFromText(text); const savedAt=savePriceDB(); $('priceMeta').textContent='Сохранено: '+new Date(savedAt).toLocaleString(); updatePriceStats();
};
$('priceSave').onclick=()=>{ const text=$('priceText').value; localStorage.setItem('_tmp_price_text', text); const savedAt=savePriceDB(); $('priceMeta').textContent='Сохранено: '+new Date(savedAt).toLocaleString(); updatePriceStats(); if(state.calc) renderSpec(); };
$('priceExport').onclick=()=>{ const rows=[]; function pushMap(map,tag,mat){ for(const k of Object.keys(map).sort((a,b)=>a-b)){ rows.push(`${tag} ${mat} ${k}А = ${fmtNum(map[k])}`); } }
  pushMap(priceDB.straight.AL,'STRAIGHT','AL'); pushMap(priceDB.straight.CU,'STRAIGHT','CU');
  pushMap(priceDB.elbow.AL,'ELBOW','AL'); pushMap(priceDB.elbow.CU,'ELBOW','CU');
  pushMap(priceDB.joint.AL,'JOINT','AL'); pushMap(priceDB.joint.CU,'JOINT','CU');
  pushMap(priceDB.endcap.AL,'ENDCAP','AL'); pushMap(priceDB.endcap.CU,'ENDCAP','CU');
  pushMap(priceDB.feeder.AL,'FEEDER','AL'); pushMap(priceDB.feeder.CU,'FEEDER','CU');
  pushMap(priceDB.transformer.AL,'TRANSFORMER','AL'); pushMap(priceDB.transformer.CU,'TRANSFORMER','CU');
  priceDB.mountRanges.AL.forEach(r=>rows.push(`MOUNT AL ${r.min}-${r.max}А = ${fmtNum(r.price)}`));
  priceDB.mountRanges.CU.forEach(r=>rows.push(`MOUNT CU ${r.min}-${r.max}А = ${fmtNum(r.price)}`));
  const blob=new Blob([rows.join('\n')],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='prices_export.txt'; a.click(); URL.revokeObjectURL(url);
};
$('priceReset').onclick=()=>{ if(confirm('Сбросить прайс к заводскому?')){ importPricesFromText(PRICE_TEXT_DEFAULT); const savedAt=savePriceDB(); $('priceText').value=PRICE_TEXT_DEFAULT.trim(); $('priceMeta').textContent='Сохранено: '+new Date(savedAt).toLocaleString(); updatePriceStats(); if(state.calc) renderSpec(); } };
function updatePriceStats(){
  const a=Object.keys(priceDB.straight.AL).length+Object.keys(priceDB.elbow.AL).length+Object.keys(priceDB.joint.AL).length+Object.keys(priceDB.endcap.AL).length+Object.keys(priceDB.feeder.AL).length+Object.keys(priceDB.transformer.AL).length+priceDB.mountRanges.AL.length;
  const c=Object.keys(priceDB.straight.CU).length+Object.keys(priceDB.elbow.CU).length+Object.keys(priceDB.joint.CU).length+Object.keys(priceDB.endcap.CU).length+Object.keys(priceDB.feeder.CU).length+Object.keys(priceDB.transformer.CU).length+priceDB.mountRanges.CU.length;
  $('priceStats').textContent=`AL: ${a} поз., CU: ${c} поз.`;
}

/* ========= СТАРТ ========= */
function start(){
  const sel=$('rating'); sel.innerHTML=''; R_AL.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); });
  resize(); setProjection('ISO'); draw(); fit();
  // загрузить прайс (из LS или по умолчанию)
  const meta=loadPriceDB(); if(!meta.loaded){ importPricesFromText(PRICE_TEXT_DEFAULT); savePriceDB(); }
}
document.addEventListener('DOMContentLoaded',start);
start();
</script>
</body>
</html>
